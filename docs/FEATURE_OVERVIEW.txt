UPLOAD BRIDGE – FEATURE OVERVIEW
================================

This document enumerates every major capability in the Upload Bridge “Design Tools” stack, explains how each feature works internally, and outlines the practical workflow for using it during LED matrix production. Readers can treat this as a “deep dive” companion to the in-app experience and existing README material.


1. CANVAS AUTHORING TOOLBOX
---------------------------
What it does:
    • Provides a high-resolution LED matrix canvas with point-and-click painting tools.
    • Supports direct manipulation of pixels, shapes, gradients, and fills with palette-backed colors.
    • Integrates undo/redo history and layer awareness so edits are recoverable and scoped.
    • Adds Random Spray and Gradient brush tools plus a multi-frame broadcast toggle to accelerate repetitive fills.

How it works:
    • The UI `MatrixDesignCanvas` raises input events (mouse, stylus, touch) that flow through `CanvasController`.
    • `CanvasController` consults `LayerManager` and `FrameManager` to map screen coordinates to per-frame pixel indices.
    • Painting operations stash pre-change pixel buffers in `_pending_paint_state`; once the stroke completes, a `FrameStateCommand` is pushed into `HistoryManager` to enable undo/redo.
    • The palette is stored on the `PatternState`; components subscribe to changes so palette edits immediately update paint buttons.
    • Random/gradient brushes pull palette endpoints from the gradient controls, while broadcast strokes forward every pixel update to `LayerManager` for each frame.

How to use:
    1. Load or create a pattern (toolbar → “New Design” or file import).
    2. Pick a drawing tool (Pixel, Rectangle, Circle, Line, Fill, Gradient, etc.) in the “Drawing Tools” group.
    3. Choose active color via the palette or color picker.
    4. Draw directly on the canvas; toggle layers to edit specific components.
    5. Enable “Apply brush strokes to all frames” when broadcasting gradients/random spray passes across entire animations.
    6. Use undo/redo for corrections and the status strip to keep track of frame, layer, memory usage, and coordinates.


2. FRAME & LAYER MANAGEMENT
---------------------------
What it does:
    • Manages multi-frame animations with per-frame duration and ordering.
    • Offers per-frame, per-layer editing so artists can isolate background, mid-ground, and overlay elements.
    • Provides warnings when frame sizes diverge from pattern metadata or when imported dimensions change.

How it works:
    • `TimelineWidget` displays frames, handles drag-to-reorder, duplication, deletion, and duration editing.
    • `LayerPanelWidget` exposes layers managed by `LayerManager`; when a layer changes, `LayerManager` syncs composite pixels back into `FrameManager`.
    • `_update_dimension_source_label` reads metadata snapshots (captured during imports) and surfaces mismatch warnings directly in the UI.
    • Transport controls (play/pause, loop, FPS spin) drive `_playback_timer` to animate frames in the canvas.

How to use:
    1. Use timeline buttons (+, copy, delete) to organize frames.
    2. Set frame duration by editing the numeric fields on each frame tile or via global FPS control.
    3. In the layer panel, toggle visibility/lock states and select the active drawing layer.
    4. Watch for warning badges indicating mismatched dimensions; adjust via width/height spins or re-import settings if necessary.


3. AUTOMATION QUEUE (LEGACY “FRAME BAKING” FLOW)
-----------------------------------------------
What it does:
    • Allows users to script transformations (scroll, wipe, mirror, rotate, color cycle, etc.).
    • Can generate preview frames or permanently bake new frames based on sequential actions.
    • Bridges manual painting and LMS runtime automation by converting queued actions to LMS instructions when finalized.
    • Offers an Automation Wizard to stack repeatable actions and optional post-processing hooks (fade in/out, overlay duplication) in one dialog.

How it works:
    • When a user adds an automation action, a `DesignAction` object is created with its parameters validated against `ACTION_PARAM_CONFIG`.
    • `_apply_actions_to_frames(finalize=False)` instantiates `PreviewSimulator`, simulates up to 50 frames, and temporarily swaps the pattern to preview results.
    • `_apply_actions_to_frames(finalize=True)` maps every `DesignAction` to an `LMSInstruction` via `_convert_action_to_instruction`, adds them to a `PatternInstructionSequence`, and persists them into `pattern.lms_pattern_instructions`.
    • Gap values entered in milliseconds are translated into frame spacing based on `_frame_duration_ms`.

How to use:
    1. Open the Automation panel; add actions such as Scroll Up, Rotate 90°, Mirror Horizontal, etc.
    2. Set repeat counts and gaps per action using the parameter inspector.
    3. Launch the wizard when you want to queue multiple operations with shared repeats/gaps or fade hooks without editing each inspector manually.
    4. Click “Preview Effect” to view simulation (non-destructive preview).
    5. Click “Finalize Automation” to convert the queue into LMS instructions stored on the pattern for MCU export.


4. LMS AUTOMATION SUITE
-----------------------
4a. Instruction Builder
    What it does:
        • Builds raw MCU runtime instructions referencing Layer 1/Layer 2/Mask frame slots.
        • Supports built-in LMS actions (moveLeft1, rotate90, mirrorH, brightness, etc.) and custom codes.
        • Captures repeat count, gap spacing (frame intervals), optional brightness deltas, and arbitrary JSON parameters.

    How it works:
        • Source/Layer2/Mask combos bind to `LayerBinding` objects; they stay synchronized with the current frame list via `_refresh_lms_frame_bindings`.
        • Action selection uses `KNOWN_LMS_ACTIONS`, adding a “Custom…” entry that unlocks a free-form code input.
        • `_on_lms_add_instruction` validates selections, deserializes extra parameters from JSON, constructs `LMSInstruction`, wraps it in `PatternInstruction`, and appends it to `_lms_sequence`.
        • `_persist_lms_sequence` mirrors `_lms_sequence` into `pattern.lms_pattern_instructions` so exports see the latest data.

    How to use:
        1. Go to “LMS Automation” → “Instruction Builder”.
        2. Pick a source frame (Layer 1) and optional Layer 2 or mask frame (set combo to “None” to skip).
        3. Choose an LMS action or select “Custom…” to supply a custom MCU opcode.
        4. Set repeat count, gap spacing (in frames), and optional brightness delta.
        5. Enter extra parameters as JSON (e.g., {"speed": 2, "direction": "reverse"}).
        6. Click “Add Instruction” to queue it; status label confirms additions.

4b. Queue & Preview
    What it does:
        • Displays the ordered LMS instruction playlist.
        • Enables reordering, duplication, removal, and clearing of instructions.
        • Simulates the playlist against the current pattern to preview MCU runtime behavior without baking frames.

    How it works:
        • `QListWidget` entries mirror `_lms_sequence`; summary label uses `PatternInstructionSequence.summarize()` to display counts.
        • Preview uses `PreviewSimulator` which takes the original pattern, runs through each instruction (respecting repeats/gaps), and returns simulated frames.
        • `_on_lms_preview_sequence` stores the original pattern in `_lms_preview_snapshot`, swaps the preview frames in, refreshes the UI, and updates the status label.
        • `_on_lms_exit_preview` restores the original pattern and clears the preview snapshot.

    How to use:
        1. Select instructions in the list to edit or reorder them.
        2. Use “Move Up/Down”, “Duplicate”, and “Remove” buttons for playlist management.
        3. Set a max frame count and click “Preview Sequence” to visualize runtime behavior.
        4. Use “Exit Preview” to return to editing the original frames.

4c. Import / Export / Analysis Tools
    What it does:
        • Imports LEDS files (metadata + instructions) and exports the current pattern/instruction set.
        • Analyzes DAT, HEX, and BIN files to surface width, height, frame count, color order, and other metadata before flashing hardware.
        • Logs operations in a read-only pane to aid troubleshooting.

    How it works:
        • Import: `parse_leds_file` reads metadata headers, instructions, and optional data; `_set_lms_sequence` loads them into the UI.
        • Export: `write_leds_file` writes metadata (width/height/frames/color order, etc.) plus each instruction line for use in LMS firmware.
        • Analyze DAT: `parse_dat_file` parses header rows and yields row data; width/height detection ensures subsequent imports know the geometry.
        • Analyze HEX: `parse_hex_file` validates Intel HEX records, checks checksums, and infers dimensions from record lengths.
        • Analyze BIN: `parse_bin_stream` inspects payload size, tries to infer pixel dimensions given common bytes-per-pixel formats, and reports candidate dimensions.

    How to use:
        1. Use “Import LEDS…” to pull existing LMS sequences; confirm metadata in the popup.
        2. Use “Export LEDS…” once the pattern + instruction queue is ready; the tool writes directly to disk and logs the destination.
        3. Use “Analyze DAT/HEX/BIN…” to examine vendor files before flashing; read results in the log or popup dialogs to ensure width/height/order match hardware.


5. CUSTOM EFFECTS ENGINE
------------------------
What it does:
    • Provides eight CPU-side effects (Fade In/Out, Blur, Sharpen, Brightness Adjust, Contrast Adjust, Color Shift, Noise, Pixelate) with intensity control.
    • Allows previewing an effect on a single frame and applying it across a frame range.

How it works:
    • When previewing, `_preview_custom_effect` creates a deep copy of the pattern (one time per session), modifies the selected frame, loads it into the canvas, then restores the original pattern after showing the preview.
    • On apply, `_apply_custom_effect` iterates from `frame_start_spin` to `frame_end_spin`, mutating pixel arrays in place; the history manager gets updated via `pattern_modified.emit()`.
    • Each effect (e.g., blur, sharpen) manipulates pixel grids by calling `_frame_to_grid` and `_grid_to_frame`, ensuring width/height metadata stays authoritative.

How to use:
    1. In the “Apply Effect” panel, choose “Custom Effect” from the effect type combo.
    2. Click “Preview Effect”; in the dialog choose a specific effect and intensity (1–100%).
    3. Inspect the preview (message explains frame count and effect); adjust intensity if needed.
    4. Click “Apply Effect” to commit changes to the selected frame range.
    5. The status panel updates, and the timeline refreshes to show modified frames.


6. FILE IMPORTERS, EXPORTERS, AND METADATA GUARDS
-------------------------------------------------
What it does:
    • Supports opening patterns from BIN, DAT, HEX, LEDS, and other formats, auto-detecting dimensions and wiring hints where possible.
    • Provides multiple exporters (raw binary, intel hex, LEDS, MCU templates) with consistent metadata annotation.
    • Tracks the origin of dimensions (header vs heuristic vs manual) to warn users if sizes drift.

How it works:
    • `core/io/lms_formats.py` defines parse/detect functions (DAT, HEX, BIN, LEDS) and raises `LMSFormatError` on invalid data to surface clear dialogs to users.
    • `core/file_format_detector.py` and `core/dimension_scorer.py` score candidate dimensions, giving the UI confidence scores to display.
    • Metadata snapshots capture the original width/height, LED count, frame count, etc., so `_update_dimension_source_label` can tell the user if the current project diverges from the imported data.
    • Exporters (e.g., `core/pattern_exporter.py`, `core/export_options.py`) marshal frame data, ordering, color packing, serpentine mapping, and orientation flags for MCU templates.

How to use:
    1. Use “Import Pattern” to load DAT/HEX/BIN/LEDS; review the “Dimension Source” label to understand where width/height came from.
    2. If auto-detection picks the wrong geometry, adjust width/height manually and re-run detection or use heuristics described in docs/automation resources.
    3. Export via the Tools → Export path or the dedicated exporter UI; confirm options such as row/column order, serpentine toggle, color order, bit depth, and brightness scaling before saving.


7. DIAGNOSTICS & HARDWARE SUPPORT
---------------------------------
What it does:
    • Provides scripts and assets to validate hardware alignment (speed, brightness, pixel order, wiring combinations).
    • Ships sample patterns (e.g., `diagnostic_12x6.bin`) and test harnesses to ensure MCU firmware outputs match previews.
    • Offers documentation (Troubleshooting Guide, Auto Detect summary, etc.) to interpret results.

How it works:
    • Python scripts (verify_speed_brightness_pixel_order.py, verify_all_16_wiring_combinations.py, test_all_patterns.py) iterate through auto-detection logic, ensuring each combination maps correctly to MCU instructions.
    • `create_diagnostic_pattern.py` generates known-good patterns for physical inspection; `wifi_upload` and `firmware/templates` provide ready-to-flash reference firmware for MCUs.
    • `final fixing and upgrade plan resources` consolidates LED Matrix Studio research, ensuring the app mirrors canonical workflows for exports and automation.

How to use:
    1. Run diagnostic scripts after significant changes or before shipping firmware to confirm auto-detection/wiring tables remain accurate.
    2. Flash diagnostic patterns to real hardware; compare physical output with on-screen preview.
    3. Consult troubleshooting documentation if disparities appear; adjust matrix mapper settings, color orders, or wiring hints accordingly.


8. THEME & UX FACILITIES
------------------------
What it does:
    • Offers dark/light themes with consistent styling across canvas, timeline, dialogs, and tabs.
    • Provides timeline zoom, status overlays, FPS controls, and loop toggles for better preview fidelity.
    • Shows inline warnings for dimension mismatches, missing actions, and import/export errors.

How it works:
    • `THEME_DEFINITIONS` describes UI palettes; `_apply_theme` propagates them to widgets and CSS.
    • Playback controls read `_playback_timer` state to enable/disable buttons; overlay labels show current loop mode and frame duration.
    • `_maybe_autosync_preview` ensures the LED simulator stays aligned with the canvas state.

How to use:
    1. Choose theme via the “Appearance” group; the entire UI restyles live.
    2. Use playback buttons (Play/Pause/Stop/Next/Prev) plus loop toggle to audition animations.
    3. Rely on status labels to confirm dimension sources, frame counts, effect states, and warnings before exporting.


9. PACKAGE CREATION & DISTRIBUTION SCRIPTS
------------------------------------------
What it does:
    • `create_complete_package.py` bundles core app files, docs, diagnostics, firmware templates, and Wi-Fi upload resources into timestamped ZIPs ready for distribution.
    • `create_deployment_package.py` or similar scripts build targeted releases for MCU flashing or specific customer handoffs.

How it works:
    • Scripts enumerate essential files/directories, skip transient artifacts (e.g., __pycache__), and tally added/missing assets.
    • Provides console output listing what was included vs missing; final summary includes package size and instructions for using the compiled ZIP.

How to use:
    1. Ensure dependencies exist (docs, firmware templates, diagnostic tools).
    2. Run `python create_complete_package.py`; inspect the console for missing file warnings.
    3. Distribute the generated ZIP along with release notes or test matrices to stakeholders.


10. DOCUMENTATION SET
---------------------
What it does:
    • Supplies narrative documentation: README, PACKAGE_README, auto-detect summaries, universal fix summaries, troubleshooting guides, and deep research on LED Matrix Studio workflows.
    • Keeps UX alignment across the app, bridging between what users see on-screen and what scripts/examples provide.

How it works:
    • Markdown docs are included in packages and referenced in the UI (e.g., help dialogs).
    • `docs/automation/lms_automation.md` outlines LMS behaviors, data structures, and differences between frame baking and runtime instructions.
    • `final fixing and upgrade plan resources` collects industry references, screen captures, and textual guides to ensure parity with MaximumOctopus’ LED Matrix Studio.

How to use:
    1. Review these docs before onboarding new users; they explain the design intent and workflows.
    2. Keep them updated when features evolve (e.g., new LMS actions, new export formats) so packages remain self-contained and accurate.


11. TESTING & VALIDATION
------------------------
What it does:
    • Unit tests (PyTest suites) cover filename hint extraction, LMS formats, automation preview simulator, instruction serialization, and more.
    • Lint checks ensure style consistency (PySide6 UI modules, domain logic, etc.).
    • Manual regression checklists (derived from this document) confirm feature flows remain intact beyond automated coverage.

How it works:
    • `tests/unit/test_filename_hints.py` validates detection heuristics for serpentine, corner hints, and naming conventions.
    • `tests/unit/test_lms_formats.py` checks DAT/HEX/BIN/LEDS parsing logic, including checksum validation and error handling.
    • Additional tests under `tests/automation`, `tests/gui`, `tests/integration`, etc., concentrate on preview simulators, instruction sequences, and UI-level behaviors (where feasible).

How to use:
    1. Run targeted pytests (`python -m pytest tests/unit/test_filename_hints.py tests/unit/test_lms_formats.py -v`) after touching detection logic or LMS import/export code.
    2. Execute broader test suites (automation, integration) before packaging releases.
    3. Maintain manual checklists derived from this overview to ensure scenario coverage, especially for UI interactions that are hard to automate.


12. SAFETY, SCRATCHPADS & TEMPLATE TOOLING
-----------------------------------------
What it does:
    • Adds a ten-slot scratchpad manager so artists can copy/paste reusable frames or motifs between projects without exports.
    • Ships a bitmap Font Designer + repository, exposes MCU-friendly code template exports (Arduino PROGMEM, PIC assembly, plain RGB arrays), and includes a one-click backup for custom fonts.
    • Introduces configurable autosave plus live memory usage warnings so oversize animations are caught before flashing devices.

How it works:
    • `ScratchpadManager` persists slot data on `pattern.scratchpads` and reuses the layer/history flow so copy/paste respects undo/redo.
    • `BitmapFontRepository` stores JSON glyph maps under `Res/fonts`, while `FontDesignerDialog` edits glyphs via a grid—the text animation pipeline checks for an active bitmap font before falling back to the built-in 5×7 set.
    • `core/export_templates.py` defines ready-made code templates rendered via `render_template`; the Export tab drives the UI and writes the generated code directly to disk alongside backups.
    • Autosave uses a `QTimer` that writes JSON snapshots to `build/autosaves`; `_update_status_labels` now reads `Pattern.estimate_memory_bytes()` and surfaces warnings in the header when nearing MCU limits.
    • The font backup button zips `Res/fonts` via `shutil.make_archive` so custom assets survive handoffs.

How to use:
    1. Open the “Scratchpads” tab, copy frames into slots 1–10, and paste them into future projects or automation flows.
    2. Launch “Font Designer…” from the Text Animation group to build bespoke bitmap fonts, then select them from the new Font combo when generating typed/scrolling text.
    3. Go to Export → “MCU Code Templates” to pick a target template and save the generated source file; use “Backup Custom Fonts…” to archive `Res/fonts` before sharing packages.
    4. Enable autosave in Appearance (choose an interval) and monitor the header’s “Memory” label for oversize projects before flashing hardware.


NEXT STEPS & ETHICAL COMPLETENESS
---------------------------------
• Use this guide as a reference when onboarding testers or stakeholders.
• When new features ship, append corresponding sections describing what the feature does, internal architecture, and usage instructions.
• Align documentation and diagnostics with user workflows so “critical thinking” checks (beyond automated tests) remain repeatable.


