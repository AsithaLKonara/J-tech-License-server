LED MATRIX STUDIO – FEATURE & WORKFLOW COMPENDIUM
=================================================

Sources referenced:
    [1] Xtronic.org – “Download LED Matrix Studio 0.1 LED Projects”
    [2] 320Volt.com – “LED Matrix Studio Arduino, Microchip” (site currently gated by a
        verification wall; information summarized here relies on mirrored release notes and
        earlier documentation compiled from that article.)

This note focuses exclusively on the stock LED Matrix Studio application (the original tool
distributed on SourceForge) and explains every major feature the legacy UI exposes, how it works
internally, and how to use it when preparing LED matrix assets for Arduino, PIC, PICAXE, Parallax,
and similar controllers.


1. MATRIX CONFIGURATION & DISPLAY MODES
--------------------------------------
What it is:
    • Global project definition covering width/height (up to 256×256 officially, with larger beta
      builds handling 512×512) and color depth (single-color, bi-color, 3-bit RGB, or full 24-bit
      RGB).
    • Includes specialty geometries: rectangular grids, circular matrices, hollow squares, radial
      and semi-circle preview mappings.

How it works:
    • The project file stores dimensions plus color mode; every drawing operation references this
      metadata when indexing pixels.
    • Circular/arc previews map rectangular coordinates onto polar coordinates so artists can
      simulate ring displays without redrawing assets.

How to use:
    1. Launch LED Matrix Studio → File → New.
    2. Pick the matrix size, color depth, and pixel style (square, round, rounded square).
    3. Choose default brush size (1×1, 2×2, 3×3) and preview magnification; adjust later via the
       toolbar.


2. DRAWING & EDITING TOOLS
--------------------------
What it is:
    • Complete pixel editor with multiple draw modes: single-click toggle, freehand, filled/empty
      rectangles, filled/empty circles, A→B line tool, multi-draw (edit all frames at once), text
      insertion (fonts up to 5×7), random color spray, gradient brush, and flood fill.
    • Transformation set: flip, mirror, invert, rotate, scroll.

How it works:
    • Tools modify the active layer/frame buffer; undo/redo is per-frame with effectively unlimited
      history according to available RAM.
    • Multi-draw broadcasts operations across every frame, allowing quick background changes.

How to use:
    1. Select a tool from the toolbar or right-click menu.
    2. Left-click to draw; right-click usually erases or toggles state depending on the mode.
    3. Use transformations via the Tools menu to adjust orientation once a frame or range is
       selected.


3. FRAME & ANIMATION MANAGEMENT
-------------------------------
What it is:
    • Unlimited frames (practically bounded by RAM: e.g., 100k RGB frames at 64×64 ≈ 3.7 GB).
    • Frame list provides duplication, multi-select deletion, and reordering.
    • Import/export handlers for animated GIFs or bitmap frame sequences; export back to GIF for
      quick previews.

How it works:
    • Frames are stored sequentially with metadata referencing duration and palette overrides.
    • GIF importer slices each frame into the matrix grid, respecting serpentine wiring options.
    • GIF exporter uses the current preview scale to write a standard animated GIF for marketing or
      validation.

How to use:
    1. Use the frame navigator (arrow icons) to move or insert frames.
    2. Import an animated GIF via File → Import; choose whether to append to existing frames.
    3. Run Tools → Animation Preview to audition at hardware speed before exporting.


4. LAYERS, BUFFERS & PRESETS
----------------------------
What it is:
    • Unlimited layers per frame (with RAM caveat) so complex scenes can be built modularly.
    • Ten user buffers/scratchpads for quick copy/paste experiments.
    • Preset manager storing resolution/color/buffer combos for frequently targeted hardware.

How it works:
    • Each layer stack merges down when exporting; toggles let you hide or lock a layer while
      editing.
    • Scratchpads behave like secondary clipboards; you can copy a frame or selection into a buffer
      and paste later, even across projects.

How to use:
    1. Enable layers in the Layers palette; add background, midground, and text layers.
    2. Use Scratchpad menu items to copy/paste recurring motifs (e.g., company logo).
    3. Save presets for 8×8 mono, 16×32 bi-color, 64×32 RGB, etc., to speed up new project
       creation.


5. TEXT & FONT DESIGNER
-----------------------
What it is:
    • Built-in text tool that places characters on the matrix using included 5×7 and 3×5 fonts.
    • Dedicated font designer mode supporting single-color or RGB glyph creation.

How it works:
    • Fonts are stored as bitmaps; the designer writes them to external files that can be swapped
      into the text tool.
    • Text tool supports per-character spacing and direction, ideal for ticker animations.

How to use:
    1. Switch to Font Designer when you need a custom typeface; draw each glyph and save the font.
    2. Return to the main canvas, choose Text tool, select your custom font, and click to place
       characters.


6. AUTOMATIC ANIMATION CREATION (TOOLS → AUTOMATE)
--------------------------------------------------
What it is:
    • Wizard-like system generating animations by applying scripted actions: scrolls, wipes,
      reveals, bounces, rotations, color cycles, etc.
    • Supports incremental frame creation so you do not need to hand-edit every intermediate state.

How it works:
    • The Automate dialog collects parameters (direction, offset per frame, number of frames).
    • The engine applies the chosen transformation frame-by-frame, optionally stacking multiple
      actions (e.g., color cycle + scroll).
    • Post-processing hooks (fade, layering) can run after core automation to add polish.

How to use:
    1. Prepare at least one source frame; open Tools → Automate.
    2. Select an action (e.g., Scroll Right 32 px over 16 frames) and configure offsets.
    3. Preview inside the dialog; if satisfied, click Generate to append frames to the project.


7. PREVIEW MODES
----------------
What it is:
    • Zoom controls from 1× up to 50× to view tiny matrices on desktop screens.
    • Alternate mapping displays: inline preview, detached window (handy for dual monitors),
      radial/semi-circle/three-quarter circle projections.

How it works:
    • Preview window reads the current frame buffer and re-renders it with chosen pixel style and
      magnification.
    • Radial mapping rotates indices so columnar data appears on arcs, approximating physical LED
      rings.

How to use:
    1. Click Preview → choose zoom level or mapping style.
    2. Use the detached window for live monitoring while editing other frames.
    3. For round displays, switch to radial mapping to ensure animation flow matches hardware.


8. IMPORT / EXPORT & CODE TEMPLATES
-----------------------------------
What it is:
    • Export engine covering binary, decimal, or hex output with optional prefixes ($ or 0x) and
      bracket styles (normal, curly, square).
    • Template system under `codeTemplates` for MCU-specific formatting (Arduino, PIC, PICAXE,
      Parallax, etc.).
    • Binary export can target raw FLASH images (.bin) or be embedded inside C/ASM files.

How it works:
    • Export dialog lets you choose scan order (rows vs columns), wiring (alternate up/down for
      serpentine), color order, and brightness scaling.
    • Template placeholders insert width, height, frame count, and pixel data automatically.

How to use:
    1. Open Export → choose target (code or binary).
    2. Set number format, bracket style, and orientation to match your driver hardware.
    3. Select a template (e.g., Arduino PROGMEM array) or export raw data for custom firmware.
    4. Save the file; embed it directly into your MCU project or convert to DAT/HEX for flashing.


9. RANDOMIZATION, GRADIENT & BRUSH SETTINGS
-------------------------------------------
What it is:
    • Random color tool for twinkling effects, noise overlays, or star fields.
    • Gradient brush allows smooth color transitions; middle mouse button draws gradient sweeps.
    • Brush settings extend from 1×1 to 3×3; pixel styles (square, round, rounded) change preview
      aesthetics.

How it works:
    • Randomizer selects palette entries or generates RGB values within configured ranges.
    • Gradient brush interpolates from start color to end color while you drag, blending per pixel.

How to use:
    1. Activate Random or Gradient brush from the toolbar.
    2. Configure palette endpoints; drag across the matrix to apply.
    3. Combine with Multi-draw to lay gradients across every frame simultaneously.


10. UNDO/REDO, AUTO-SAVE & PROJECT FILES
----------------------------------------
What it is:
    • Per-frame undo/redo stack with “unlimited” depth constrained only by RAM.
    • Auto-save option writes project snapshots to disk at set intervals.
    • Native file format preserves frames, layers, palettes, scratchpads, presets, and export
      settings.

How it works:
    • Each edit pushes a delta into the undo stack; redo clears whenever a new stroke occurs.
    • Auto-save monitors the dirty flag; when triggered, it writes `.lms` (or equivalent) files to
      the chosen directory.

How to use:
    1. Enable Auto-save in Preferences if you work on large projects.
    2. Use Ctrl+Z/Shift+Ctrl+Z (or toolbar icons) to navigate history per frame.
    3. Save often; keep incremental versions before running large automation batches.


11. WORKFLOW SUMMARY
--------------------
    1. Define the matrix (size, color depth, pixel style) and load or create base art.
    2. Use layers, scratchpads, and drawing tools to develop scenes.
    3. Leverage Automate for motion, or manually duplicate frames for fine-tuned animation.
    4. Preview via zoom/radial windows; iterate until visuals match hardware expectations.
    5. Run export with proper wiring/format settings; optionally apply code templates for Arduino,
       PIC, PICAXE, or Parallax.
    6. Embed exported data into MCU firmware and validate on physical panels.


12. PRACTICAL TIPS FROM HISTORICAL USERS
----------------------------------------
    • Memory planning: 256×256 RGB frames consume significant RAM; keep backup copies on disk
      rather than relying solely on undo stacks.
    • Layer budgeting: each extra layer multiplies RAM usage; flatten layers before running huge
      automation jobs.
    • GIF import quirks: limit GIF dimensions to your matrix size to avoid cropping; LED Matrix
      Studio does not resample larger images automatically.
    • Microcontroller targeting: use templates tailored to your platform to avoid manual byte-order
      fixes; the SourceForge package includes ready-made templates for Arduino PROGMEM arrays and
      PIC assembly tables.
    • Serpentine wiring: always double-check Alternate Up/Down settings during export to match how
      your panel is wired.


13. LIMITATIONS & FUTURE-SAFE PRACTICES
---------------------------------------
    • Official builds cap at 256×256, though some beta users reported success at 1024×1024 with
      enough RAM; expect UI lag at extreme sizes.
    • Layer counts are unlimited in theory but quickly grow memory use; flatten when possible.
    • Automation scripts assume rectangular matrices; radial preview is visual-only, so export data
      remains rectangular.
    • Auto-detection of wiring is not included; you must set scan order and alternate mode manually
      during export.
    • Keep backups of the `codeTemplates` folder; customizing templates for different MCU IDEs is a
      common workflow and easy to lose during upgrades.


This document should live alongside other references in the `docs/` folder so engineers can quickly
refresh themselves on the stock LED Matrix Studio toolset when validating compatibility or
recreating OEM workflows.



