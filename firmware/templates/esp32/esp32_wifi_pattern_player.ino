/**
 * ESP32 WiFi LED Pattern Player - Upload Bridge Template
 * 
 * Plays LED animation patterns with WiFi upload capability
 * Generated by Upload Bridge - github.com/yourname/upload-bridge
 */

#include <FastLED.h>
#include <pgmspace.h>
#include <WiFi.h>
#include <WebServer.h>
#include <SPIFFS.h>
#include "pattern_data.h"  // Auto-generated by Upload Bridge

// WiFi settings
const char* ssid = "ESP32_Pattern_Player";
const char* password = "uploadbridge123";

// Default settings (overridden by pattern_data.h)
#ifndef DATA_PIN
#define DATA_PIN 2
#endif

#ifndef LED_COUNT
#define LED_COUNT 76
#endif

#define LED_TYPE    WS2812B
#define COLOR_ORDER GRB
#define MAX_LEDS    1024

// LED buffer in RAM
CRGB leds[MAX_LEDS];

// Web server
WebServer server(80);

// Function prototypes
uint16_t read_u16_pgm(const uint8_t *ptr, uint32_t idx);
uint8_t read_u8_pgm(const uint8_t *ptr, uint32_t idx);
void handleRoot();
void handleUpload();
void handlePattern();
void playPattern();

void setup() {
    // Initialize serial
    Serial.begin(115200);
    Serial.println();
    Serial.println("ESP32 WiFi Pattern Player - Upload Bridge");
    
    // Initialize SPIFFS
    if(!SPIFFS.begin(true)){
        Serial.println("SPIFFS Mount Failed");
        return;
    }
    
    // Initialize FastLED
    FastLED.addLeds<LED_TYPE, DATA_PIN, COLOR_ORDER>(leds, min(LED_COUNT, MAX_LEDS));
    FastLED.setBrightness(BRIGHTNESS);
    FastLED.clear(true);
    
    // Validate pattern data
    if (pattern_data_size < 4) {
        Serial.println("ERROR: Pattern data invalid!");
        return;
    }
    
    Serial.printf("LEDs: %d, Frames: %d\n", LED_COUNT, FRAME_COUNT);
    
    // Setup WiFi Access Point
    WiFi.softAP(ssid, password);
    IPAddress IP = WiFi.softAPIP();
    Serial.print("AP IP address: ");
    Serial.println(IP);
    
    // Setup web server routes
    server.on("/", handleRoot);
    server.on("/upload", HTTP_POST, handleUpload);
    server.on("/pattern", handlePattern);
    
    server.begin();
    Serial.println("HTTP server started");
    Serial.println("Pattern player ready!");
}

void loop() {
    server.handleClient();
    playPattern();
}

void playPattern() {
    static unsigned long lastFrame = 0;
    static uint16_t currentFrame = 0;
    
    if (millis() - lastFrame >= FRAME_DELAY_MS) {
        // Read frame data from PROGMEM
        for(uint16_t led = 0; led < LED_COUNT; led++) {
            uint32_t pixel_offset = (currentFrame * LED_COUNT + led) * 3;
            
            uint8_t r = read_u8_pgm(pattern_data, pixel_offset);
            uint8_t g = read_u8_pgm(pattern_data, pixel_offset + 1);
            uint8_t b = read_u8_pgm(pattern_data, pixel_offset + 2);
            
            leds[led] = CRGB(r, g, b);
        }
        
        FastLED.show();
        currentFrame = (currentFrame + 1) % FRAME_COUNT;
        lastFrame = millis();
    }
}

void handleRoot() {
    String html = "<!DOCTYPE html><html><head><title>ESP32 Pattern Player</title></head><body>";
    html += "<h1>ESP32 LED Pattern Player</h1>";
    html += "<p>LEDs: " + String(LED_COUNT) + "</p>";
    html += "<p>Frames: " + String(FRAME_COUNT) + "</p>";
    html += "<p>Pattern Size: " + String(pattern_data_size) + " bytes</p>";
    html += "<form action='/upload' method='post' enctype='multipart/form-data'>";
    html += "<input type='file' name='pattern' accept='.bin,.leds,.json'>";
    html += "<input type='submit' value='Upload Pattern'>";
    html += "</form>";
    html += "</body></html>";
    
    server.send(200, "text/html", html);
}

void handleUpload() {
    HTTPUpload& upload = server.upload();
    
    if (upload.status == UPLOAD_FILE_START) {
        Serial.printf("Upload: %s\n", upload.filename.c_str());
    } else if (upload.status == UPLOAD_FILE_WRITE) {
        // Handle file upload
        Serial.printf("Upload: %u bytes\n", upload.currentSize);
    } else if (upload.status == UPLOAD_FILE_END) {
        Serial.printf("Upload: %s (%u bytes)\n", upload.filename.c_str(), upload.totalSize);
        server.send(200, "text/plain", "Upload complete");
    }
}

void handlePattern() {
    server.send(200, "application/octet-stream", String((char*)pattern_data, pattern_data_size));
}

// Helper functions for PROGMEM access
uint16_t read_u16_pgm(const uint8_t *ptr, uint32_t idx) {
    return pgm_read_word(ptr + idx);
}

uint8_t read_u8_pgm(const uint8_t *ptr, uint32_t idx) {
    return pgm_read_byte(ptr + idx);
}

