// esp8266_wifi_pattern_player.ino
// ESP8266 WiFi Pattern Player for Upload Bridge
// Reads pattern data from PROGMEM and displays on WS2812/NeoPixel LEDs
// Includes WiFi web server for uploading new patterns over-the-air
// 
// Requirements:
// - FastLED library (install via Arduino Library Manager)
// - ESP8266WiFi library (included with ESP8266 core)
// - ESP8266WebServer library (included with ESP8266 core)
// - pattern_data.h (generated by Upload Bridge)

#include <Arduino.h>
#include <FastLED.h>
#include <pgmspace.h> // for PROGMEM access
#include <ESP8266WiFi.h>
#include <ESP8266WebServer.h>
#include <ESP8266mDNS.h>
#include <FS.h>

// ---------- CONFIG ----------
#define DATA_PIN    D4        // GPIO2 on NodeMCU/ESP-12E (change if needed)
                              // Common alternatives: D1 (GPIO5), D2 (GPIO4), etc.
#define LED_TYPE    WS2812B
#define COLOR_ORDER GRB
#define MAX_LEDS    512       // Maximum LEDs supported (adjust to your hardware)
                              // Must be >= the number of LEDs in your pattern

// WiFi Configuration
const char* ssid = "LEDMatrix_ESP8266";  // AP mode SSID
const char* password = "ledmatrix123";   // AP mode password
const char* hostname = "ledmatrix";

// Web server on port 80
ESP8266WebServer server(80);

// LED array (allocated in RAM for FastLED)
CRGB leds[MAX_LEDS];

// Pattern management
bool pattern_loaded = false;
uint16_t current_num_leds = 0;
uint16_t current_num_frames = 0;
uint32_t current_pattern_size = 0;
uint8_t* current_pattern_data = nullptr;

// Include the pattern data (generated by Upload Bridge)
// This file must be in the same folder as this .ino file
#include "pattern_data.h"

// ---------- HELPER FUNCTIONS ----------

// Read little-endian uint16 from PROGMEM at given index
uint16_t read_u16_pgm(const uint8_t *ptr, uint32_t idx) {
  uint8_t b0 = pgm_read_byte(ptr + idx);
  uint8_t b1 = pgm_read_byte(ptr + idx + 1);
  return (uint16_t)(b0 | (b1 << 8));
}

// Read single byte from PROGMEM
uint8_t read_u8_pgm(const uint8_t *ptr, uint32_t idx) {
  return pgm_read_byte(ptr + idx);
}

// Read little-endian uint16 from RAM
uint16_t read_u16_ram(const uint8_t *ptr, uint32_t idx) {
  return ptr[idx] | (ptr[idx + 1] << 8);
}

// Read single byte from RAM
uint8_t read_u8_ram(const uint8_t *ptr, uint32_t idx) {
  return ptr[idx];
}

// ---------- WEB SERVER HANDLERS ----------

void handleRoot() {
  String html = R"(
<!DOCTYPE html>
<html>
<head>
    <title>Upload Bridge WiFi Pattern Player</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background: #f0f0f0; }
        .container { max-width: 600px; margin: 0 auto; background: white; padding: 20px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        h1 { color: #2196F3; text-align: center; }
        .status { padding: 10px; margin: 10px 0; border-radius: 5px; }
        .success { background: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .error { background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
        .info { background: #d1ecf1; color: #0c5460; border: 1px solid #bee5eb; }
        .upload-area { border: 2px dashed #ccc; padding: 20px; text-align: center; margin: 20px 0; border-radius: 5px; }
        .upload-area:hover { border-color: #2196F3; background: #f8f9fa; }
        button { background: #2196F3; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; margin: 5px; }
        button:hover { background: #1976D2; }
        .progress { width: 100%; height: 20px; background: #f0f0f0; border-radius: 10px; overflow: hidden; margin: 10px 0; }
        .progress-bar { height: 100%; background: #2196F3; width: 0%; transition: width 0.3s; }
        input[type="file"] { display: none; }
        .file-info { margin: 10px 0; padding: 10px; background: #f8f9fa; border-radius: 5px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üé® Upload Bridge WiFi Pattern Player</h1>
        
        <div class="status info">
            <strong>Current Status:</strong> 
            <span id="status">Loading...</span>
        </div>
        
        <div class="file-info" id="pattern-info" style="display: none;">
            <strong>Current Pattern:</strong><br>
            LEDs: <span id="current-leds">-</span><br>
            Frames: <span id="current-frames">-</span><br>
            Size: <span id="current-size">-</span> bytes
        </div>
        
        <div class="upload-area" onclick="document.getElementById('fileInput').click()">
            <p>üìÅ Click here to select pattern file (.bin)</p>
            <p style="font-size: 12px; color: #666;">Supports .bin, .hex, .dat formats</p>
            <input type="file" id="fileInput" accept=".bin,.hex,.dat" onchange="handleFileSelect(this)">
        </div>
        
        <div id="file-details" style="display: none;">
            <div class="file-info">
                <strong>Selected File:</strong><br>
                Name: <span id="file-name">-</span><br>
                Size: <span id="file-size">-</span> bytes<br>
                LEDs: <span id="file-leds">-</span><br>
                Frames: <span id="file-frames">-</span>
            </div>
            <button onclick="uploadPattern()">üöÄ Upload Pattern</button>
            <button onclick="clearSelection()">‚ùå Clear Selection</button>
        </div>
        
        <div class="progress" id="progress-container" style="display: none;">
            <div class="progress-bar" id="progress-bar"></div>
        </div>
        
        <div id="upload-result"></div>
        
        <div style="margin-top: 30px; text-align: center;">
            <button onclick="location.reload()">üîÑ Refresh Status</button>
            <button onclick="window.open('http://192.168.4.1/status', '_blank')">üìä Detailed Status</button>
        </div>
    </div>
    
    <script>
        let selectedFile = null;
        
        function updateStatus() {
            fetch('/api/status')
                .then(response => response.json())
                .then(data => {
                    document.getElementById('status').textContent = data.status;
                    if (data.pattern_loaded) {
                        document.getElementById('current-leds').textContent = data.num_leds;
                        document.getElementById('current-frames').textContent = data.num_frames;
                        document.getElementById('current-size').textContent = data.pattern_size;
                        document.getElementById('pattern-info').style.display = 'block';
                    }
                })
                .catch(error => {
                    document.getElementById('status').textContent = 'Error loading status';
                });
        }
        
        function handleFileSelect(input) {
            if (input.files && input.files[0]) {
                selectedFile = input.files[0];
                document.getElementById('file-name').textContent = selectedFile.name;
                document.getElementById('file-size').textContent = selectedFile.size.toLocaleString();
                document.getElementById('file-details').style.display = 'block';
                
                // Try to parse pattern info from file
                const reader = new FileReader();
                reader.onload = function(e) {
                    const data = new Uint8Array(e.target.result);
                    if (data.length >= 4) {
                        const numLeds = data[0] | (data[1] << 8);
                        const numFrames = data[2] | (data[3] << 8);
                        document.getElementById('file-leds').textContent = numLeds;
                        document.getElementById('file-frames').textContent = numFrames;
                    }
                };
                reader.readAsArrayBuffer(selectedFile.slice(0, 4));
            }
        }
        
        function uploadPattern() {
            if (!selectedFile) return;
            
            const formData = new FormData();
            formData.append('pattern', selectedFile);
            
            document.getElementById('progress-container').style.display = 'block';
            document.getElementById('upload-result').innerHTML = '';
            
            const xhr = new XMLHttpRequest();
            
            xhr.upload.onprogress = function(e) {
                if (e.lengthComputable) {
                    const percentComplete = (e.loaded / e.total) * 100;
                    document.getElementById('progress-bar').style.width = percentComplete + '%';
                }
            };
            
            xhr.onload = function() {
                document.getElementById('progress-container').style.display = 'none';
                if (xhr.status === 200) {
                    const response = JSON.parse(xhr.responseText);
                    if (response.success) {
                        document.getElementById('upload-result').innerHTML = 
                            '<div class="status success">‚úÖ Pattern uploaded successfully!<br>' + response.message + '</div>';
                        updateStatus();
                    } else {
                        document.getElementById('upload-result').innerHTML = 
                            '<div class="status error">‚ùå Upload failed: ' + response.message + '</div>';
                    }
                } else {
                    document.getElementById('upload-result').innerHTML = 
                        '<div class="status error">‚ùå Upload failed with status: ' + xhr.status + '</div>';
                }
            };
            
            xhr.onerror = function() {
                document.getElementById('progress-container').style.display = 'none';
                document.getElementById('upload-result').innerHTML = 
                    '<div class="status error">‚ùå Upload failed: Network error</div>';
            };
            
            xhr.open('POST', '/api/upload');
            xhr.send(formData);
        }
        
        function clearSelection() {
            selectedFile = null;
            document.getElementById('fileInput').value = '';
            document.getElementById('file-details').style.display = 'none';
            document.getElementById('upload-result').innerHTML = '';
        }
        
        // Update status on page load
        updateStatus();
        
        // Update status every 5 seconds
        setInterval(updateStatus, 5000);
    </script>
</body>
</html>
)";
  
  server.send(200, "text/html", html);
}

void handleStatus() {
  String json = "{";
  json += "\"status\":\"" + String(pattern_loaded ? "Pattern Loaded" : "No Pattern") + "\",";
  json += "\"pattern_loaded\":" + String(pattern_loaded ? "true" : "false") + ",";
  json += "\"num_leds\":" + String(current_num_leds) + ",";
  json += "\"num_frames\":" + String(current_num_frames) + ",";
  json += "\"pattern_size\":" + String(current_pattern_size) + ",";
  json += "\"wifi_mode\":\"AP\",";
  json += "\"ssid\":\"" + String(ssid) + "\",";
  json += "\"ip\":\"192.168.4.1\"";
  json += "}";
  
  server.send(200, "application/json", json);
}

void handleUpload() {
  HTTPUpload& upload = server.upload();
  
  if (upload.status == UPLOAD_FILE_START) {
    Serial.println("Upload started: " + upload.filename);
    
    // Validate file extension
    String filename = upload.filename;
    if (!filename.endsWith(".bin") && !filename.endsWith(".hex") && !filename.endsWith(".dat")) {
      server.send(400, "application/json", "{\"success\":false,\"message\":\"Invalid file format. Use .bin, .hex, or .dat files.\"}");
      return;
    }
    
    // Free previous pattern data
    if (current_pattern_data != nullptr) {
      free(current_pattern_data);
      current_pattern_data = nullptr;
    }
    
    pattern_loaded = false;
    
  } else if (upload.status == UPLOAD_FILE_WRITE) {
    // Allocate memory for pattern data
    if (current_pattern_data == nullptr) {
      current_pattern_data = (uint8_t*)malloc(upload.totalSize);
      if (current_pattern_data == nullptr) {
        Serial.println("ERROR: Failed to allocate memory for pattern");
        server.send(500, "application/json", "{\"success\":false,\"message\":\"Failed to allocate memory for pattern\"}");
        return;
      }
      current_pattern_size = upload.totalSize;
    }
    
    // Copy uploaded data
    memcpy(current_pattern_data + upload.currentSize - upload.bufsize, upload.buf, upload.bufsize);
    
  } else if (upload.status == UPLOAD_FILE_END) {
    Serial.println("Upload complete: " + upload.filename + " (" + String(upload.totalSize) + " bytes)");
    
    // Validate pattern data
    if (current_pattern_size < 4) {
      server.send(400, "application/json", "{\"success\":false,\"message\":\"Pattern file too small\"}");
      return;
    }
    
    // Parse pattern header
    current_num_leds = read_u16_ram(current_pattern_data, 0);
    current_num_frames = read_u16_ram(current_pattern_data, 2);
    
    // Validate pattern
    if (current_num_leds == 0 || current_num_leds > MAX_LEDS) {
      server.send(400, "application/json", "{\"success\":false,\"message\":\"Invalid LED count: " + String(current_num_leds) + "\"}");
      return;
    }
    
    if (current_num_frames == 0) {
      server.send(400, "application/json", "{\"success\":false,\"message\":\"Invalid frame count: 0\"}");
      return;
    }
    
    // Calculate expected size
    uint32_t expected_size = 4 + (current_num_frames * (2 + current_num_leds * 3));
    if (current_pattern_size != expected_size) {
      server.send(400, "application/json", "{\"success\":false,\"message\":\"Pattern size mismatch. Expected: " + String(expected_size) + ", Got: " + String(current_pattern_size) + "\"}");
      return;
    }
    
    pattern_loaded = true;
    
    String message = "Pattern loaded: " + String(current_num_leds) + " LEDs √ó " + String(current_num_frames) + " frames (" + String(current_pattern_size) + " bytes)";
    Serial.println(message);
    
    server.send(200, "application/json", "{\"success\":true,\"message\":\"" + message + "\"}");
  }
}

void handleNotFound() {
  server.send(404, "text/plain", "Not Found");
}

// ---------- PATTERN PLAYBACK ----------

void playPattern() {
  if (!pattern_loaded || current_pattern_data == nullptr) {
    return;
  }
  
  const uint8_t *p = current_pattern_data;
  uint32_t idx = 0;
  
  // Read pattern header
  uint16_t num_leds = read_u16_ram(p, idx); 
  idx += 2;
  uint16_t num_frames = read_u16_ram(p, idx); 
  idx += 2;
  
  // Play all frames
  for (uint32_t frame_num = 0; frame_num < num_frames; ++frame_num) {
    // Check bounds
    if (idx + 2 > current_pattern_size) {
      Serial.printf("ERROR: Unexpected end of data at frame %u\n", frame_num);
      return;
    }
    
    // Read frame delay (milliseconds)
    uint16_t delay_ms = read_u16_ram(p, idx); 
    idx += 2;
    
    // Check if we have enough data for all pixel bytes
    uint32_t pixel_bytes = (uint32_t)num_leds * 3;
    if (idx + pixel_bytes > current_pattern_size) {
      Serial.printf("ERROR: Not enough pixel data at frame %u\n", frame_num);
      return;
    }
    
    // Read RGB data for each LED
    for (uint16_t led_idx = 0; led_idx < num_leds; ++led_idx) {
      uint8_t r = read_u8_ram(p, idx++);
      uint8_t g = read_u8_ram(p, idx++);
      uint8_t b = read_u8_ram(p, idx++);
      leds[led_idx] = CRGB(r, g, b);
    }
    
    // Display the frame
    FastLED.show();
    
    // Accurate delay with watchdog feeding
    if (delay_ms > 0) {
      if (delay_ms >= 10) {
        uint32_t chunks = delay_ms / 10;
        uint32_t remainder = delay_ms % 10;
        
        for (uint32_t i = 0; i < chunks; i++) {
          delay(10);
          yield();
        }
        
        if (remainder > 0) {
          delay(remainder);
        }
      } else {
        delay(delay_ms);
      }
      yield();
    } else {
      yield();
    }
  }
}

void playDefaultPattern() {
  const uint8_t *p = pattern_data; // Pointer to pattern data in PROGMEM
  uint32_t idx = 0;

  // Read pattern header (4 bytes)
  if (pattern_data_size < 4) {
    Serial.println("ERROR: Pattern data too small!");
    return;
  }

  uint16_t num_leds = read_u16_pgm(p, idx); 
  idx += 2;
  uint16_t num_frames = read_u16_pgm(p, idx); 
  idx += 2;

  // Validate pattern header
  if (num_leds == 0 || num_leds > MAX_LEDS) {
    Serial.printf("ERROR: Invalid num_leds=%u (MAX_LEDS=%u)\n", num_leds, MAX_LEDS);
    return;
  }

  if (num_frames == 0) {
    Serial.println("ERROR: num_frames=0");
    return;
  }

  // Play all frames
  for (uint32_t frame_num = 0; frame_num < num_frames; ++frame_num) {
    // Check bounds
    if (idx + 2 > pattern_data_size) {
      Serial.printf("ERROR: Unexpected end of data at frame %u\n", frame_num);
      return;
    }

    // Read frame delay (milliseconds)
    uint16_t delay_ms = read_u16_pgm(p, idx); 
    idx += 2;

    // Check if we have enough data for all pixel bytes
    uint32_t pixel_bytes = (uint32_t)num_leds * 3;
    if (idx + pixel_bytes > pattern_data_size) {
      Serial.printf("ERROR: Not enough pixel data at frame %u\n", frame_num);
      return;
    }

    // Read RGB data for each LED
    for (uint16_t led_idx = 0; led_idx < num_leds; ++led_idx) {
      uint8_t r = read_u8_pgm(p, idx++);
      uint8_t g = read_u8_pgm(p, idx++);
      uint8_t b = read_u8_pgm(p, idx++);
      leds[led_idx] = CRGB(r, g, b);
    }

    // Display the frame
    FastLED.show();

    // Accurate delay with watchdog feeding
    if (delay_ms > 0) {
      if (delay_ms >= 10) {
        uint32_t chunks = delay_ms / 10;
        uint32_t remainder = delay_ms % 10;
        
        for (uint32_t i = 0; i < chunks; i++) {
          delay(10);
          yield();
        }
        
        if (remainder > 0) {
          delay(remainder);
        }
      } else {
        delay(delay_ms);
      }
      yield();
    } else {
      yield();
    }
  }
}

// ---------- SETUP ----------
void setup() {
  Serial.begin(115200);
  delay(100);
  Serial.println("\n\nUpload Bridge WiFi Pattern Player");
  Serial.println("==================================");
  
  // Initialize FastLED
  FastLED.addLeds<LED_TYPE, DATA_PIN, COLOR_ORDER>(leds, MAX_LEDS);
  FastLED.setBrightness(255);  // Full brightness (adjust 0-255)
  FastLED.clear(true);
  
  delay(50);
  Serial.println("‚úì FastLED initialized");
  
  // Setup WiFi in AP mode
  WiFi.mode(WIFI_AP);
  WiFi.softAP(ssid, password);
  
  // Configure AP
  IPAddress apIP(192, 168, 4, 1);
  WiFi.softAPConfig(apIP, apIP, IPAddress(255, 255, 255, 0));
  
  Serial.println("‚úì WiFi AP started");
  Serial.println("SSID: " + String(ssid));
  Serial.println("Password: " + String(password));
  Serial.println("IP: 192.168.4.1");
  
  // Setup web server
  server.on("/", handleRoot);
  server.on("/api/status", handleStatus);
  server.on("/api/upload", HTTP_POST, []() {
    server.send(200, "application/json", "{\"success\":true,\"message\":\"Upload endpoint ready\"}");
  }, handleUpload);
  server.onNotFound(handleNotFound);
  
  server.begin();
  Serial.println("‚úì Web server started");
  
  // Setup mDNS
  if (MDNS.begin(hostname)) {
    Serial.println("‚úì mDNS responder started");
    Serial.println("Access via: http://" + String(hostname) + ".local");
  }
  
  // Load default pattern if available
  if (pattern_data_size > 0) {
    Serial.printf("‚úì Default pattern loaded: %u bytes\n", pattern_data_size);
    
    // Parse default pattern header
    uint16_t num_leds = read_u16_pgm(pattern_data, 0);
    uint16_t num_frames = read_u16_pgm(pattern_data, 2);
    
    Serial.printf("Default pattern: %u LEDs √ó %u frames\n", num_leds, num_frames);
  } else {
    Serial.println("‚ö† No default pattern data found");
  }
  
  Serial.println("\nüåê Web interface available at:");
  Serial.println("   http://192.168.4.1");
  Serial.println("   http://" + String(hostname) + ".local");
  Serial.println("\nüì± Connect to WiFi network:");
  Serial.println("   SSID: " + String(ssid));
  Serial.println("   Password: " + String(password));
  Serial.println("\n‚úì Starting playback...\n");
}

// ---------- MAIN LOOP ----------
void loop() {
  // Handle web server requests
  server.handleClient();
  
  // Play pattern (either uploaded or default)
  if (pattern_loaded) {
    playPattern();
  } else {
    playDefaultPattern();
  }
  
  // Small pause between loops
  delay(10);
  yield();
}

