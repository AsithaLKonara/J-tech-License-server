/**
 * Professional ATmega328P LED Pattern Player - Upload Bridge Template
 * 
 * Full professional-grade pattern player with all advanced features
 * Optimized for ATmega328P with 32KB flash and 2KB RAM
 * Generated by Upload Bridge - Professional Edition
 */

#include <avr/io.h>
#include <avr/interrupt.h>
#include <avr/pgmspace.h>
#include <util/delay.h>
#include <math.h>
#include <string.h>
#include "pattern_data.h"

// WS2812 timing constants (for 16MHz clock)
#define T1H  900    // 0.9us
#define T1L  350    // 0.35us
#define T0H  350    // 0.35us  
#define T0L  900    // 0.9us
#define RES  50000  // 50us reset

// Advanced brightness control
#define BRIGHTNESS_CURVE_LINEAR 0
#define BRIGHTNESS_CURVE_GAMMA_CORRECTED 1
#define BRIGHTNESS_CURVE_LOGARITHMIC 2
#define BRIGHTNESS_CURVE_EXPONENTIAL 3
#define BRIGHTNESS_CURVE_S_CURVE 4

// Speed control
#define SPEED_CURVE_LINEAR 0
#define SPEED_CURVE_EASE_IN_QUAD 1
#define SPEED_CURVE_EASE_OUT_QUAD 2
#define SPEED_CURVE_EASE_IN_OUT_QUAD 3
#define SPEED_CURVE_EASE_IN_CUBIC 4
#define SPEED_CURVE_EASE_OUT_CUBIC 5
#define SPEED_CURVE_EASE_IN_OUT_CUBIC 6

// Default settings (overridden by pattern_data.h)
#ifndef DATA_PIN
#define DATA_PIN 2
#endif

#ifndef LED_COUNT
#define LED_COUNT 76
#endif

#define MAX_LEDS 200  // Optimized for ATmega328P memory

// LED buffer in RAM
uint8_t led_buffer[MAX_LEDS * 3];

// Global settings
float global_brightness = 1.0;
float red_brightness = 1.0;
float green_brightness = 1.0;
float blue_brightness = 1.0;
bool per_channel_brightness = false;
uint8_t brightness_curve = BRIGHTNESS_CURVE_GAMMA_CORRECTED;
uint8_t speed_curve = SPEED_CURVE_LINEAR;
bool variable_speed = false;
bool interpolation_enabled = false;
float interpolation_factor = 1.0;

// Speed keyframes (max 8 keyframes for memory efficiency)
struct SpeedKeyframe {
    uint16_t frame;
    float multiplier;
};
SpeedKeyframe speed_keyframes[8];
uint8_t num_keyframes = 0;

// Interpolation buffer for smooth transitions
uint8_t interpolation_buffer[MAX_LEDS * 3];

// Function prototypes
void ws2812_init(uint8_t pin);
void ws2812_send_byte(uint8_t byte);
void ws2812_send(uint8_t *data, uint16_t len);
uint16_t read_u16_pgm(const uint8_t *ptr, uint16_t idx);
uint8_t read_u8_pgm(const uint8_t *ptr, uint16_t idx);
float apply_brightness_curve(float value, uint8_t curve_type);
float apply_speed_curve(float t, uint8_t curve_type);
uint16_t get_frame_delay(uint16_t base_delay, uint32_t frame, uint32_t total_frames);
void apply_brightness_to_pixel(uint8_t *r, uint8_t *g, uint8_t *b, float brightness);
void interpolate_frames(uint8_t *frame1, uint8_t *frame2, uint8_t *output, float t, uint16_t led_count);
void process_frame_with_interpolation(const uint8_t *pattern_data, uint16_t frame_idx, uint16_t total_frames, uint16_t led_count);

int main(void) {
    // Initialize WS2812 pin as output
    if (DATA_PIN < 8) {
        DDRD |= (1 << DATA_PIN);
    } else {
        DDRB |= (1 << (DATA_PIN - 8));
    }
    
    // Load advanced settings from pattern metadata
    global_brightness = BRIGHTNESS / 255.0;
    red_brightness = red_brightness / 255.0;
    green_brightness = green_brightness / 255.0;
    blue_brightness = blue_brightness / 255.0;
    per_channel_brightness = per_channel_brightness;
    brightness_curve = brightness_curve;
    speed_curve = speed_curve;
    variable_speed = variable_speed;
    interpolation_enabled = interpolation_enabled;
    interpolation_factor = interpolation_factor / 10.0;
    
    // Load speed keyframes
    num_keyframes = num_keyframes;
    for (uint8_t i = 0; i < num_keyframes && i < 8; i++) {
        speed_keyframes[i].frame = speed_keyframes[i].frame;
        speed_keyframes[i].multiplier = speed_keyframes[i].multiplier;
    }
    
    // Main loop
    while (1) {
        // Read pattern header
        const uint8_t *p = pattern_data;
        uint32_t idx = 0;
        
        uint16_t num_leds = read_u16_pgm(p, idx);
        idx += 2;
        
        uint16_t num_frames = read_u16_pgm(p, idx);
        idx += 2;
        
        // Limit LED count to available memory
        if (num_leds > MAX_LEDS) {
            num_leds = MAX_LEDS;
        }
        
        // Play all frames with advanced features
        for (uint32_t frame = 0; frame < num_frames; frame++) {
            process_frame_with_interpolation(p, frame, num_frames, num_leds);
        }
    }
}

void process_frame_with_interpolation(const uint8_t *pattern_data, uint16_t frame_idx, uint16_t total_frames, uint16_t led_count) {
    // Read frame delay
    uint16_t base_delay = read_u16_pgm(pattern_data, 4 + frame_idx * (led_count * 3 + 2));
    
    // Apply speed curve if enabled
    uint16_t delay_ms = get_frame_delay(base_delay, frame_idx, total_frames);
    
    // Read current frame
    uint32_t frame_offset = 4 + frame_idx * (led_count * 3 + 2) + 2;
    for (uint16_t led = 0; led < led_count; led++) {
        uint8_t r = read_u8_pgm(pattern_data, frame_offset + led * 3);
        uint8_t g = read_u8_pgm(pattern_data, frame_offset + led * 3 + 1);
        uint8_t b = read_u8_pgm(pattern_data, frame_offset + led * 3 + 2);
        
        // Apply advanced brightness
        apply_brightness_to_pixel(&r, &g, &b, global_brightness);
        
        // Store in buffer
        led_buffer[led * 3] = r;
        led_buffer[led * 3 + 1] = g;
        led_buffer[led * 3 + 2] = b;
    }
    
    // Apply interpolation if enabled
    if (interpolation_enabled && frame_idx < total_frames - 1) {
        // Read next frame for interpolation
        uint32_t next_frame_offset = 4 + (frame_idx + 1) * (led_count * 3 + 2) + 2;
        for (uint16_t led = 0; led < led_count; led++) {
            uint8_t r = read_u8_pgm(pattern_data, next_frame_offset + led * 3);
            uint8_t g = read_u8_pgm(pattern_data, next_frame_offset + led * 3 + 1);
            uint8_t b = read_u8_pgm(pattern_data, next_frame_offset + led * 3 + 2);
            
            // Apply brightness to next frame
            apply_brightness_to_pixel(&r, &g, &b, global_brightness);
            
            // Store in interpolation buffer
            interpolation_buffer[led * 3] = r;
            interpolation_buffer[led * 3 + 1] = g;
            interpolation_buffer[led * 3 + 2] = b;
        }
        
        // Interpolate between frames
        float t = 1.0 / interpolation_factor;
        interpolate_frames(led_buffer, interpolation_buffer, led_buffer, t, led_count);
    }
    
    // Send to LEDs
    ws2812_send(led_buffer, led_count * 3);
    
    // Delay with watchdog feeding
    if (delay_ms >= 10) {
        // Long delay: yield every 10ms to feed watchdog
        uint32_t chunks = delay_ms / 10;
        uint32_t remainder = delay_ms % 10;
        
        for (uint32_t i = 0; i < chunks; i++) {
            _delay_ms(10);
        }
        
        if (remainder > 0) {
            _delay_ms(remainder);
        }
    } else if (delay_ms > 0) {
        _delay_ms(delay_ms);
    }
}

float apply_brightness_curve(float value, uint8_t curve_type) {
    if (value < 0.0) value = 0.0;
    if (value > 1.0) value = 1.0;
    
    switch (curve_type) {
        case BRIGHTNESS_CURVE_LINEAR:
            return value;
            
        case BRIGHTNESS_CURVE_GAMMA_CORRECTED:
            // Optimized gamma correction using lookup table
            return value * value; // Simplified gamma 2.0 for memory efficiency
            
        case BRIGHTNESS_CURVE_LOGARITHMIC:
            if (value == 0.0) return 0.0;
            // Simplified logarithmic curve
            return (value * value + value) / 2.0;
            
        case BRIGHTNESS_CURVE_EXPONENTIAL:
            return value * value;
            
        case BRIGHTNESS_CURVE_S_CURVE:
            // Optimized S-curve
            float x = value;
            return 3.0 * x * x - 2.0 * x * x * x;
            
        default:
            return value;
    }
}

float apply_speed_curve(float t, uint8_t curve_type) {
    if (t < 0.0) t = 0.0;
    if (t > 1.0) t = 1.0;
    
    switch (curve_type) {
        case SPEED_CURVE_LINEAR:
            return t;
            
        case SPEED_CURVE_EASE_IN_QUAD:
            return t * t;
            
        case SPEED_CURVE_EASE_OUT_QUAD:
            return 1 - (1 - t) * (1 - t);
            
        case SPEED_CURVE_EASE_IN_OUT_QUAD:
            if (t < 0.5) return 2 * t * t;
            return 1 - 2 * (1 - t) * (1 - t);
            
        case SPEED_CURVE_EASE_IN_CUBIC:
            return t * t * t;
            
        case SPEED_CURVE_EASE_OUT_CUBIC:
            float f = 1 - t;
            return 1 - f * f * f;
            
        case SPEED_CURVE_EASE_IN_OUT_CUBIC:
            if (t < 0.5) return 4 * t * t * t;
            float f2 = 1 - t;
            return 1 - 4 * f2 * f2 * f2;
            
        default:
            return t;
    }
}

uint16_t get_frame_delay(uint16_t base_delay, uint32_t frame, uint32_t total_frames) {
    if (!variable_speed) {
        return base_delay;
    }
    
    // Apply speed curve
    float t = (float)frame / (total_frames - 1);
    float curve_factor = apply_speed_curve(t, speed_curve);
    
    // Apply keyframes if available
    float keyframe_factor = 1.0;
    for (uint8_t i = 0; i < num_keyframes; i++) {
        if (frame >= speed_keyframes[i].frame) {
            keyframe_factor = speed_keyframes[i].multiplier;
        }
    }
    
    return (uint16_t)(base_delay / (curve_factor * keyframe_factor));
}

void apply_brightness_to_pixel(uint8_t *r, uint8_t *g, uint8_t *b, float brightness) {
    if (per_channel_brightness) {
        // Per-channel brightness control
        *r = (uint8_t)(*r * brightness * red_brightness);
        *g = (uint8_t)(*g * brightness * green_brightness);
        *b = (uint8_t)(*b * brightness * blue_brightness);
    } else {
        // Apply brightness curve
        float curved_brightness = apply_brightness_curve(brightness, brightness_curve);
        
        *r = (uint8_t)(*r * curved_brightness);
        *g = (uint8_t)(*g * curved_brightness);
        *b = (uint8_t)(*b * curved_brightness);
    }
}

void interpolate_frames(uint8_t *frame1, uint8_t *frame2, uint8_t *output, float t, uint16_t led_count) {
    for (uint16_t led = 0; led < led_count; led++) {
        uint8_t r1 = frame1[led * 3];
        uint8_t g1 = frame1[led * 3 + 1];
        uint8_t b1 = frame1[led * 3 + 2];
        
        uint8_t r2 = frame2[led * 3];
        uint8_t g2 = frame2[led * 3 + 1];
        uint8_t b2 = frame2[led * 3 + 2];
        
        // Linear interpolation
        output[led * 3] = (uint8_t)(r1 + (r2 - r1) * t);
        output[led * 3 + 1] = (uint8_t)(g1 + (g2 - g1) * t);
        output[led * 3 + 2] = (uint8_t)(b1 + (b2 - b1) * t);
    }
}

// WS2812 bit-banging functions (optimized for ATmega328P)
void ws2812_init(uint8_t pin) {
    if (pin < 8) {
        DDRD |= (1 << pin);
    } else {
        DDRB |= (1 << (pin - 8));
    }
}

void ws2812_send_byte(uint8_t byte) {
    for (uint8_t i = 0; i < 8; i++) {
        if (byte & 0x80) {
            // Send 1
            if (DATA_PIN < 8) {
                PORTD |= (1 << DATA_PIN);
                _delay_us(1);  // ~0.9us
                PORTD &= ~(1 << DATA_PIN);
                _delay_us(1);  // ~0.35us
            } else {
                PORTB |= (1 << (DATA_PIN - 8));
                _delay_us(1);
                PORTB &= ~(1 << (DATA_PIN - 8));
                _delay_us(1);
            }
        } else {
            // Send 0
            if (DATA_PIN < 8) {
                PORTD |= (1 << DATA_PIN);
                _delay_us(1);  // ~0.35us
                PORTD &= ~(1 << DATA_PIN);
                _delay_us(1);  // ~0.9us
            } else {
                PORTB |= (1 << (DATA_PIN - 8));
                _delay_us(1);
                PORTB &= ~(1 << (DATA_PIN - 8));
                _delay_us(1);
            }
        }
        byte <<= 1;
    }
}

void ws2812_send(uint8_t *data, uint16_t len) {
    for (uint16_t i = 0; i < len; i++) {
        ws2812_send_byte(data[i]);
    }
    _delay_us(50);  // Reset pulse
}

// Helper functions
uint16_t read_u16_pgm(const uint8_t *ptr, uint32_t idx) {
    uint8_t b0 = pgm_read_byte(ptr + idx);
    uint8_t b1 = pgm_read_byte(ptr + idx + 1);
    return (uint16_t)(b0 | (b1 << 8));
}

uint8_t read_u8_pgm(const uint8_t *ptr, uint32_t idx) {
    return pgm_read_byte(ptr + idx);
}













