# Firmware Templates - Upload Bridge

This directory contains firmware templates for different microcontroller families.

## Available Templates

### ESP8266 / ESP32
- **Path**: `esp8266/`
- **Language**: Arduino C++
- **Build System**: Arduino CLI
- **Features**: 
  - FastLED library for WS2812/NeoPixel
  - Watchdog-safe delays
  - Serial debugging
  - Auto-generated pattern_data.h

### ATmega328P (Arduino UNO/Nano)
- **Path**: `atmega328p/`
- **Language**: C (bare metal)
- **Build System**: avr-gcc
- **Features**:
  - Bit-banging WS2812 protocol
  - Optimized for size
  - PROGMEM storage
  - Auto-generated pattern_data.h

## Template Structure

Each template directory contains:

```
chip_name/
├── pattern_player.{ino|c}  # Main source file
├── pattern_data.h           # Auto-generated (do not edit!)
├── Makefile                 # Optional build script
├── README.md                # Template-specific documentation
└── *.{h|c|cpp}              # Additional support files
```

## Auto-Generated Files

**pattern_data.h** is automatically generated by Upload Bridge and contains:

```c
#ifndef PATTERN_DATA_H
#define PATTERN_DATA_H

#define DATA_PIN 2
#define LED_COUNT 76
#define FRAME_COUNT 400
#define BRIGHTNESS 255

const uint32_t pattern_data_size = 91204;

const uint8_t PROGMEM pattern_data[] = {
    // Header (4 bytes)
    0x4C, 0x00,  // num_leds = 76
    0x90, 0x01,  // num_frames = 400
    
    // Frames...
    // Frame 0:
    0x14, 0x00,  // delay_ms = 20
    0xFF, 0x00, 0x00,  // LED 0: Red
    // ... more LEDs
    
    // Frame 1:
    // ...
};

#endif
```

## Creating Custom Templates

To add a new chip template:

1. Create directory: `templates/your_chip/`
2. Add source file(s) with pattern playback code
3. Include `"pattern_data.h"` for pattern data
4. Read pattern header and frames from `pattern_data[]`
5. Implement corresponding uploader in `uploaders/your_chip_uploader.py`
6. Add chip spec to `config/chip_database.yaml`

### Required Features

Your template must:
- Read `num_leds` and `num_frames` from pattern_data header
- Loop through frames, reading delay and RGB data
- Output to LED strip (WS2812/NeoPixel or other)
- Loop infinitely for continuous playback
- Handle watchdog/yield if applicable

### Pattern Data Format

```
Offset 0-1: num_leds (uint16_t, little-endian)
Offset 2-3: num_frames (uint16_t, little-endian)

Then for each frame:
  Offset 0-1: delay_ms (uint16_t, little-endian)
  Offset 2+:  RGB data (3 bytes × num_leds)
```

## Build Process

Upload Bridge handles compilation automatically:

1. Generates `pattern_data.h` from your Pattern object
2. Copies template files to build directory
3. Invokes appropriate compiler (arduino-cli, avr-gcc, etc.)
4. Produces binary (.hex or .bin)
5. Flashes to chip via appropriate tool (esptool, avrdude, etc.)

## Testing Templates

Test your template with a simple pattern:

```python
from core.pattern import create_test_pattern
from firmware.builder import FirmwareBuilder

# Create test pattern
pattern = create_test_pattern(led_count=10, frame_count=10)

# Build firmware
builder = FirmwareBuilder()
result = builder.build(pattern, "your_chip", {
    'gpio_pin': 2
})

print(f"Build result: {result.success}")
print(f"Firmware: {result.firmware_path}")
```

## License

Templates are MIT licensed. Feel free to modify and distribute.

