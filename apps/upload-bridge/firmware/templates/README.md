# Firmware Templates - Upload Bridge

This directory contains firmware templates for different microcontroller families.

## Available Templates

All templates are organized in chip-specific directories under `firmware/templates/`.

### ESP Family (Arduino C++)
- **ESP8266**: `esp8266/` - FastLED-based template with WiFi support
- **ESP32**: `esp32/` - ESP32 optimized template
- **ESP32-S2**: `esp32s2/` - ESP32-S2 specific template
- **ESP32-S3**: `esp32s3/` - ESP32-S3 specific template
- **ESP32-C3**: `esp32c3/` - ESP32-C3 RISC-V template
- **Language**: Arduino C++
- **Build System**: Arduino CLI + esptool
- **Features**: 
  - FastLED library for WS2812/NeoPixel
  - Watchdog-safe delays
  - Serial debugging
  - WiFi pattern upload (ESP8266/ESP32)
  - Auto-generated pattern_data.h

### AVR Family (C - bare metal)
- **ATmega328P**: `atmega328p/` - Arduino UNO/Nano compatible
- **ATmega2560**: `atmega2560/` - Arduino Mega compatible
- **ATtiny85**: `attiny85/` - Minimal footprint template
- **Language**: C (bare metal)
- **Build System**: avr-gcc + avrdude
- **Features**:
  - Bit-banging WS2812 protocol
  - Optimized for size
  - PROGMEM storage
  - Professional and enhanced pattern players
  - Auto-generated pattern_data.h

### STM32 Family (C - ARM Cortex-M)
- **STM32F103C8**: `stm32f103c8/` - Blue Pill compatible (64KB flash, 20KB RAM)
- **STM32F401RE**: `stm32f401re/` - STM32F4 Discovery compatible (512KB flash, 96KB RAM)
- **STM32F407**: `stm32f407/` - High-performance (1MB flash, 192KB RAM)
- **STM32F030F4P6**: `stm32f030f4p6/` - Minimal STM32 (16KB flash, 4KB RAM)
- **Language**: C (bare metal ARM)
- **Build System**: arm-none-eabi-gcc + stm32flash
- **Features**:
  - Professional pattern player with advanced features
  - Brightness curves, speed control, interpolation
  - Optimized WS2812 bit-banging
  - Auto-generated pattern_data.h

### PIC Family (C - Microchip)
- **PIC16F876A**: `pic16f876a/` - Base template for many PIC16 variants
- **PIC18F4550**: `pic18f4550/` - USB-capable PIC18
- **PIC12F/16F variants**: Use include-based stubs (see Template Stub Pattern below)
- **Language**: C (XC8 compiler)
- **Build System**: MPLAB XC8 + PIC programmer
- **Features**:
  - Memory-optimized for small PIC chips
  - Bit-field structures for settings
  - Simplified brightness/speed curves (8-bit arithmetic)
  - Auto-generated pattern_data.h

### Nuvoton Family (C - ARM Cortex-M0)
- **NUC123**: `nuc123/` - Nuvoton NUC123 (64KB flash, 20KB RAM)
- **NUC505**: `nuc505/` - Nuvoton NUC505 (128KB flash, 32KB RAM)
- **N76E003AT20**: `n76e003at20/` - 8051-based Nuvoton (uses M031 template)
- **NuMicro M031**: `numicro_m031/` - Base template for M031 series
- **Nuvoton M051**: `nuvoton_m051/` - Nuvoton M051 template
- **Language**: C (ARM Cortex-M0)
- **Build System**: arm-none-eabi-gcc + nu-link
- **Features**:
  - Professional pattern player
  - Advanced brightness and speed curves
  - Auto-generated pattern_data.h

## Template Structure

Each template directory contains:

```
chip_name/
├── {chip_name}.ino          # Arduino templates (ESP, AVR with FastLED)
├── professional_pattern_player.c  # C templates (STM32, PIC, Nuvoton)
├── pattern_data.h           # Auto-generated (do not edit!)
├── Makefile                 # Build script (for C templates)
├── README.md                # Template-specific documentation (optional)
└── *.{h|c|cpp}              # Additional support files
```

### Template Stub Pattern

Many PIC templates use an **include-based stub pattern** to reduce duplication:

```c
// Reuses PIC16F876A advanced player for pic12f508
#include "../pic16f876a/professional_pattern_player.c"
```

This pattern is **valid and recommended** for:
- Similar chips with compatible instruction sets
- Variants that only differ in pin count or memory
- Reducing maintenance overhead

The verification script recognizes this pattern and validates that:
- The included file exists
- The included file is valid and complete
- No structural issues are present

**Important**: Stub templates should include a comment explaining which base template they use.

## Auto-Generated Files

**pattern_data.h** is automatically generated by Upload Bridge and contains:

```c
#ifndef PATTERN_DATA_H
#define PATTERN_DATA_H

#define DATA_PIN 2
#define LED_COUNT 76
#define FRAME_COUNT 400
#define BRIGHTNESS 255

const uint32_t pattern_data_size = 91204;

const uint8_t PROGMEM pattern_data[] = {
    // Header (4 bytes)
    0x4C, 0x00,  // num_leds = 76
    0x90, 0x01,  // num_frames = 400
    
    // Frames...
    // Frame 0:
    0x14, 0x00,  // delay_ms = 20
    0xFF, 0x00, 0x00,  // LED 0: Red
    // ... more LEDs
    
    // Frame 1:
    // ...
};

#endif
```

## Creating Custom Templates

To add a new chip template:

1. **Create directory**: `templates/your_chip/`
2. **Add source file(s)** with pattern playback code:
   - Arduino templates: `{chip_name}.ino`
   - C templates: `professional_pattern_player.c`
3. **Include pattern_data.h**: All templates must include `"pattern_data.h"`
4. **Read pattern data**: Follow the pattern data format (see below)
5. **Respect chip limits**: Set `MAX_LEDS` based on chip memory constraints from `chip_database.yaml`
6. **Add Makefile** (for C templates): Reference similar chip Makefiles
7. **Implement uploader**: Add corresponding uploader in `uploaders/your_chip_uploader.py`
8. **Register chip**: Add chip spec to `config/chip_database.yaml`

### Template Naming Conventions

- **Arduino templates**: `{chip_id}.ino` (e.g., `esp32s2.ino`, `atmega2560.ino`)
- **C templates**: `professional_pattern_player.c` (e.g., STM32, PIC, Nuvoton)
- **Makefiles**: `Makefile` (standard name)
- **Stub templates**: Can use any name, but should include a comment explaining the include

### Required Features

Your template must:
- Read `num_leds` and `num_frames` from pattern_data header
- Loop through frames, reading delay and RGB data
- Output to LED strip (WS2812/NeoPixel or other)
- Loop infinitely for continuous playback
- Handle watchdog/yield if applicable

### Pattern Data Format

```
Offset 0-1: num_leds (uint16_t, little-endian)
Offset 2-3: num_frames (uint16_t, little-endian)

Then for each frame:
  Offset 0-1: delay_ms (uint16_t, little-endian)
  Offset 2+:  RGB data (3 bytes × num_leds)
```

## Build Process

Upload Bridge handles compilation automatically:

1. Generates `pattern_data.h` from your Pattern object
2. Copies template files to build directory
3. Invokes appropriate compiler (arduino-cli, avr-gcc, etc.)
4. Produces binary (.hex or .bin)
5. Flashes to chip via appropriate tool (esptool, avrdude, etc.)

## Testing Templates

Test your template with a simple pattern:

```python
from core.pattern import create_test_pattern
from firmware.builder import FirmwareBuilder

# Create test pattern
pattern = create_test_pattern(led_count=10, frame_count=10)

# Build firmware
builder = FirmwareBuilder()
result = builder.build(pattern, "your_chip", {
    'gpio_pin': 2
})

print(f"Build result: {result.success}")
print(f"Firmware: {result.firmware_path}")
```

## License

Templates are MIT licensed. Feel free to modify and distribute.

