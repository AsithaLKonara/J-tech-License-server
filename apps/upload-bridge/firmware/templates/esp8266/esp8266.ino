/**
 * ESP8266 LED Pattern Player - Upload Bridge Template
 * 
 * Plays LED animation patterns stored in PROGMEM
 * Generated by Upload Bridge - github.com/yourname/upload-bridge
 */

#include <FastLED.h>
#include <pgmspace.h>
#include "pattern_data.h"  // Auto-generated by Upload Bridge

// Default settings (overridden by pattern_data.h)
#ifndef DATA_PIN
#define DATA_PIN 2
#endif

#ifndef LED_COUNT
#define LED_COUNT 76
#endif

#define LED_TYPE    WS2812B
#define COLOR_ORDER GRB
#define MAX_LEDS    512

// LED buffer in RAM
CRGB leds[MAX_LEDS];

// Function prototypes
uint16_t read_u16_pgm(const uint8_t *ptr, uint32_t idx);
uint8_t read_u8_pgm(const uint8_t *ptr, uint32_t idx);

void setup() {
    // Initialize serial (if not using GPIO3/RX)
    #if DATA_PIN != 3
    Serial.begin(115200);
    Serial.println();
    Serial.println("ESP8266 Pattern Player - Upload Bridge");
    Serial.printf("Data pin: GPIO%d\n", DATA_PIN);
    Serial.printf("Pattern size: %u bytes\n", pattern_data_size);
    #endif
    
    // Initialize FastLED
    FastLED.addLeds<LED_TYPE, DATA_PIN, COLOR_ORDER>(leds, min(LED_COUNT, MAX_LEDS));
    FastLED.setBrightness(BRIGHTNESS);
    FastLED.clear(true);
    
    // Validate pattern data
    if (pattern_data_size < 4) {
        #if DATA_PIN != 3
        Serial.println("ERROR: Pattern data invalid!");
        #endif
        
        // Flash red on error
        for (int i = 0; i < 10; i++) {
            fill_solid(leds, min(LED_COUNT, MAX_LEDS), CRGB::Red);
            FastLED.show();
            delay(200);
            FastLED.clear(true);
            delay(200);
        }
        while(1) { delay(1000); }  // Halt
    }
    
    #if DATA_PIN != 3
    Serial.println("Starting playback...");
    #endif
}

void loop() {
    // Read pattern header
    const uint8_t *p = pattern_data;
    uint32_t idx = 0;
    
    uint16_t num_leds = read_u16_pgm(p, idx);
    idx += 2;
    
    uint16_t num_frames = read_u16_pgm(p, idx);
    idx += 2;
    
    // Validate
    if (num_leds == 0 || num_leds > MAX_LEDS) {
        #if DATA_PIN != 3
        Serial.printf("ERROR: Invalid LED count: %u\n", num_leds);
        #endif
        delay(5000);
        return;
    }
    
    if (num_frames == 0 || num_frames > 100000) {
        #if DATA_PIN != 3
        Serial.printf("ERROR: Invalid frame count: %u\n", num_frames);
        #endif
        delay(5000);
        return;
    }
    
    // Play all frames
    for (uint32_t frame = 0; frame < num_frames; frame++) {
        // Read frame delay
        uint16_t delay_ms = read_u16_pgm(p, idx);
        idx += 2;
        
        // Read RGB data for all LEDs
        for (uint16_t led = 0; led < num_leds; led++) {
            uint8_t r = read_u8_pgm(p, idx++);
            uint8_t g = read_u8_pgm(p, idx++);
            uint8_t b = read_u8_pgm(p, idx++);
            
            leds[led] = CRGB(r, g, b);
        }
        
        // Display frame
        FastLED.show();
        
        // Delay with watchdog feeding
        if (delay_ms >= 10) {
            // Long delay: yield every 10ms to feed watchdog
            uint32_t chunks = delay_ms / 10;
            uint32_t remainder = delay_ms % 10;
            
            for (uint32_t i = 0; i < chunks; i++) {
                delay(10);
                yield();
            }
            
            if (remainder > 0) {
                delay(remainder);
            }
        } else if (delay_ms > 0) {
            delay(delay_ms);
        }
        
        yield();  // Always yield
    }
    
    // Loop restarts automatically
    delay(10);
    yield();
}

// Helper: Read 16-bit value from PROGMEM (little-endian)
uint16_t read_u16_pgm(const uint8_t *ptr, uint32_t idx) {
    uint8_t b0 = pgm_read_byte(ptr + idx);
    uint8_t b1 = pgm_read_byte(ptr + idx + 1);
    return (uint16_t)(b0 | (b1 << 8));
}

// Helper: Read 8-bit value from PROGMEM
uint8_t read_u8_pgm(const uint8_t *ptr, uint32_t idx) {
    return pgm_read_byte(ptr + idx);
}

