/**
 * Simple ESP8266 LED Pattern Player - Compatible with Upload Bridge
 * 
 * Based on the working esp_matrix_player.ino but adapted for Upload Bridge data format
 */

#include <Arduino.h>
#include <FastLED.h>
#include <pgmspace.h>

// Include the pattern data (generated by Upload Bridge)
#include "pattern_data.h"

// ---------- HELPER FUNCTIONS ----------

// Read little-endian uint16 from PROGMEM at given index
uint16_t read_u16_pgm(const uint8_t *ptr, uint32_t idx) {
  uint8_t b0 = pgm_read_byte(ptr + idx);
  uint8_t b1 = pgm_read_byte(ptr + idx + 1);
  return (uint16_t)(b0 | (b1 << 8));
}

// Read single byte from PROGMEM
uint8_t read_u8_pgm(const uint8_t *ptr, uint32_t idx) {
  return pgm_read_byte(ptr + idx);
}

// ---------- SETUP ----------
void setup() {
  Serial.begin(115200);
  delay(100);
  Serial.println("\n\nESP8266 LED Pattern Player - Upload Bridge");
  Serial.println("==========================================");
  
  // Initialize FastLED
  FastLED.addLeds<WS2812, LED_DATA_PIN, GRB>(leds, LED_COUNT);
  FastLED.setBrightness(BRIGHTNESS);
  FastLED.clear(true);
  
  delay(50);
  Serial.println("✓ FastLED initialized");
  Serial.printf("✓ LEDs: %d, Frames: %d\n", LED_COUNT, FRAME_COUNT);
  Serial.printf("✓ Data pin: %d\n", LED_DATA_PIN);
  Serial.println("✓ Starting playback...\n");
}

// ---------- MAIN LOOP ----------
void loop() {
  // Play all frames
  for (uint16_t frame_num = 0; frame_num < FRAME_COUNT; frame_num++) {
    // Read frame delay
    uint16_t delay_ms = pgm_read_word(&frame_delays[frame_num]);
    
    // Read RGB data for each LED
    const uint8_t* frame_data = frame_data_arrays[frame_num];
    for (uint16_t led_idx = 0; led_idx < LED_COUNT; led_idx++) {
      uint8_t r = pgm_read_byte(&frame_data[led_idx * 3]);
      uint8_t g = pgm_read_byte(&frame_data[led_idx * 3 + 1]);
      uint8_t b = pgm_read_byte(&frame_data[led_idx * 3 + 2]);
      leds[led_idx] = CRGB(r, g, b);
    }

    // Display the frame
    FastLED.show();

    // Accurate delay with watchdog feeding
    if (delay_ms > 0) {
        if (delay_ms >= 10) {
            uint32_t chunks = delay_ms / 10;
            uint32_t remainder = delay_ms % 10;
            
            for (uint32_t i = 0; i < chunks; i++) {
                delay(10);
                yield();
            }
            
            if (remainder > 0) {
                delay(remainder);
            }
        } else {
            delay(delay_ms);
        }
        yield();
    } else {
        yield();
    }
  }

  // Small pause between loops
  delay(10);
  yield();
}













