/**
 * Professional PIC18F4550 LED Pattern Player - Upload Bridge Template
 * 
 * Full professional-grade pattern player with all advanced features
 * Optimized for PIC18F4550 with 32KB flash and 2KB RAM
 * Generated by Upload Bridge - Professional Edition
 */

#include <xc.h>
#include <math.h>
#include <string.h>
#include "pattern_data.h"

// Configuration bits
#pragma config FOSC = INTOSC_HS
#pragma config WDT = OFF
#pragma config LVP = OFF

// Advanced brightness control
#define BRIGHTNESS_CURVE_LINEAR 0
#define BRIGHTNESS_CURVE_GAMMA_CORRECTED 1
#define BRIGHTNESS_CURVE_LOGARITHMIC 2
#define BRIGHTNESS_CURVE_EXPONENTIAL 3
#define BRIGHTNESS_CURVE_S_CURVE 4

// Speed control
#define SPEED_CURVE_LINEAR 0
#define SPEED_CURVE_EASE_IN_QUAD 1
#define SPEED_CURVE_EASE_OUT_QUAD 2
#define SPEED_CURVE_EASE_IN_OUT_QUAD 3

// Default settings (overridden by pattern_data.h)
#ifndef DATA_PIN
#define DATA_PIN 0
#endif

#ifndef LED_COUNT
#define LED_COUNT 76
#endif

#define MAX_LEDS 100  // Optimized for PIC18F4550 memory (32KB flash, 2KB RAM)

// LED buffer in RAM (limited by PIC memory)
uint8_t led_buffer[MAX_LEDS * 3];

// Global settings (using bit fields to save memory)
struct {
    uint8_t brightness : 7;        // 0-127
    uint8_t red_brightness : 7;    // 0-127
    uint8_t green_brightness : 7;  // 0-127
    uint8_t blue_brightness : 7;   // 0-127
    uint8_t per_channel : 1;       // 0 or 1
    uint8_t brightness_curve : 3;  // 0-4
    uint8_t speed_curve : 2;       // 0-3
    uint8_t variable_speed : 1;    // 0 or 1
    uint8_t interpolation : 1;     // 0 or 1
} settings;

// Speed keyframes (max 4 keyframes for memory efficiency)
struct SpeedKeyframe {
    uint8_t frame;
    uint8_t multiplier;  // 0-255, represents 0.0-2.0
};
SpeedKeyframe speed_keyframes[4];
uint8_t num_keyframes = 0;

// Function prototypes
void ws2812_init(uint8_t pin);
void ws2812_send_byte(uint8_t byte);
void ws2812_send(uint8_t *data, uint8_t len);
uint16_t read_u16_pgm(const uint8_t *ptr, uint8_t idx);
uint8_t read_u8_pgm(const uint8_t *ptr, uint8_t idx);
uint8_t apply_brightness_curve(uint8_t value, uint8_t curve_type);
uint8_t apply_speed_curve(uint8_t t, uint8_t curve_type);
uint8_t get_frame_delay(uint8_t base_delay, uint8_t frame, uint8_t total_frames);
void apply_brightness_to_pixel(uint8_t *r, uint8_t *g, uint8_t *b, uint8_t brightness);
void process_frame(const uint8_t *pattern_data, uint8_t frame_idx, uint8_t total_frames, uint8_t led_count);
void delay_ms(uint8_t ms);

int main(void) {
    // Initialize WS2812 pin
    ws2812_init(DATA_PIN);
    
    // Load advanced settings from pattern metadata (scaled to 0-127)
    settings.brightness = BRIGHTNESS >> 1;  // Scale from 0-255 to 0-127
    settings.red_brightness = red_brightness >> 1;
    settings.green_brightness = green_brightness >> 1;
    settings.blue_brightness = blue_brightness >> 1;
    settings.per_channel = per_channel_brightness;
    settings.brightness_curve = brightness_curve;
    settings.speed_curve = speed_curve;
    settings.variable_speed = variable_speed;
    settings.interpolation = interpolation_enabled;
    
    // Load speed keyframes
    num_keyframes = num_keyframes;
    if (num_keyframes > 4) num_keyframes = 4;  // Limit for memory
    
    for (uint8_t i = 0; i < num_keyframes; i++) {
        speed_keyframes[i].frame = speed_keyframes[i].frame;
        speed_keyframes[i].multiplier = speed_keyframes[i].multiplier;
    }
    
    // Main loop
    while (1) {
        // Read pattern header
        const uint8_t *p = pattern_data;
        uint8_t idx = 0;
        
        uint8_t num_leds = read_u16_pgm(p, idx) & 0xFF;  // Limit to 8-bit
        idx += 2;
        
        uint8_t num_frames = read_u16_pgm(p, idx) & 0xFF;  // Limit to 8-bit
        idx += 2;
        
        // Limit LED count to available memory
        if (num_leds > MAX_LEDS) {
            num_leds = MAX_LEDS;
        }
        
        // Play all frames with advanced features
        for (uint8_t frame = 0; frame < num_frames; frame++) {
            process_frame(p, frame, num_frames, num_leds);
        }
    }
}

void process_frame(const uint8_t *pattern_data, uint8_t frame_idx, uint8_t total_frames, uint8_t led_count) {
    // Read frame delay
    uint8_t base_delay = read_u16_pgm(pattern_data, 4 + frame_idx * (led_count * 3 + 2)) & 0xFF;
    
    // Apply speed curve if enabled
    uint8_t delay_ms = get_frame_delay(base_delay, frame_idx, total_frames);
    
    // Read current frame
    uint8_t frame_offset = 4 + frame_idx * (led_count * 3 + 2) + 2;
    for (uint8_t led = 0; led < led_count; led++) {
        uint8_t r = read_u8_pgm(pattern_data, frame_offset + led * 3);
        uint8_t g = read_u8_pgm(pattern_data, frame_offset + led * 3 + 1);
        uint8_t b = read_u8_pgm(pattern_data, frame_offset + led * 3 + 2);
        
        // Apply advanced brightness
        apply_brightness_to_pixel(&r, &g, &b, settings.brightness);
        
        // Store in buffer
        led_buffer[led * 3] = r;
        led_buffer[led * 3 + 1] = g;
        led_buffer[led * 3 + 2] = b;
    }
    
    // Send to LEDs
    ws2812_send(led_buffer, led_count * 3);
    
    // Delay
    delay_ms(delay_ms);
}

uint8_t apply_brightness_curve(uint8_t value, uint8_t curve_type) {
    // Optimized brightness curves for PIC (8-bit arithmetic)
    switch (curve_type) {
        case BRIGHTNESS_CURVE_LINEAR:
            return value;
            
        case BRIGHTNESS_CURVE_GAMMA_CORRECTED:
            // Simplified gamma correction using lookup table
            return (value * value) >> 8;  // value^2 / 256
            
        case BRIGHTNESS_CURVE_LOGARITHMIC:
            // Simplified logarithmic curve
            return (value + (value * value >> 8)) >> 1;
            
        case BRIGHTNESS_CURVE_EXPONENTIAL:
            return (value * value) >> 8;
            
        case BRIGHTNESS_CURVE_S_CURVE:
            // Optimized S-curve for 8-bit
            uint16_t x = value;
            uint16_t x2 = (x * x) >> 8;
            uint16_t x3 = (x2 * x) >> 8;
            return (3 * x2 - 2 * x3) >> 8;
            
        default:
            return value;
    }
}

uint8_t apply_speed_curve(uint8_t t, uint8_t curve_type) {
    // Optimized speed curves for PIC (8-bit arithmetic)
    switch (curve_type) {
        case SPEED_CURVE_LINEAR:
            return t;
            
        case SPEED_CURVE_EASE_IN_QUAD:
            return (t * t) >> 8;
            
        case SPEED_CURVE_EASE_OUT_QUAD:
            return 255 - ((255 - t) * (255 - t) >> 8);
            
        case SPEED_CURVE_EASE_IN_OUT_QUAD:
            if (t < 128) {
                return (2 * t * t) >> 8;
            } else {
                uint8_t f = 255 - t;
                return 255 - (2 * f * f >> 8);
            }
            
        default:
            return t;
    }
}

uint8_t get_frame_delay(uint8_t base_delay, uint8_t frame, uint8_t total_frames) {
    if (!settings.variable_speed) {
        return base_delay;
    }
    
    // Apply speed curve
    uint8_t t = (frame * 255) / (total_frames - 1);
    uint8_t curve_factor = apply_speed_curve(t, settings.speed_curve);
    
    // Apply keyframes if available
    uint8_t keyframe_factor = 128;  // 1.0 in 8-bit
    for (uint8_t i = 0; i < num_keyframes; i++) {
        if (frame >= speed_keyframes[i].frame) {
            keyframe_factor = speed_keyframes[i].multiplier;
        }
    }
    
    // Calculate final delay (avoid division)
    uint16_t result = (base_delay * 128) / ((curve_factor * keyframe_factor) >> 7);
    return (result > 255) ? 255 : result;
}

void apply_brightness_to_pixel(uint8_t *r, uint8_t *g, uint8_t *b, uint8_t brightness) {
    if (settings.per_channel) {
        // Per-channel brightness control (8-bit arithmetic)
        *r = (*r * brightness * settings.red_brightness) >> 14;  // Scale back
        *g = (*g * brightness * settings.green_brightness) >> 14;
        *b = (*b * brightness * settings.blue_brightness) >> 14;
    } else {
        // Apply brightness curve
        uint8_t curved_brightness = apply_brightness_curve(brightness, settings.brightness_curve);
        
        *r = (*r * curved_brightness) >> 7;
        *g = (*g * curved_brightness) >> 7;
        *b = (*b * curved_brightness) >> 7;
    }
}

void ws2812_init(uint8_t pin) {
    // Configure GPIO pin for WS2812 (PIC18F4550 uses TRISB for PORTB)
    TRISB &= ~(1 << pin);  // Set as output
    PORTB &= ~(1 << pin);  // Initialize low
}

void ws2812_send_byte(uint8_t byte) {
    // PIC WS2812 bit-banging implementation (optimized for 20MHz)
    for (uint8_t i = 0; i < 8; i++) {
        if (byte & 0x80) {
            // Send 1 (0.9us high, 0.35us low)
            PORTB |= (1 << DATA_PIN);
            __delay_us(1);  // ~0.9us
            PORTB &= ~(1 << DATA_PIN);
            __delay_us(1);  // ~0.35us
        } else {
            // Send 0 (0.35us high, 0.9us low)
            PORTB |= (1 << DATA_PIN);
            __delay_us(1);  // ~0.35us
            PORTB &= ~(1 << DATA_PIN);
            __delay_us(1);  // ~0.9us
        }
        byte <<= 1;
    }
}

void ws2812_send(uint8_t *data, uint8_t len) {
    for (uint8_t i = 0; i < len; i++) {
        ws2812_send_byte(data[i]);
    }
    // Reset pulse
    PORTB &= ~(1 << DATA_PIN);
    __delay_us(50);
}

void delay_ms(uint8_t ms) {
    for (uint8_t i = 0; i < ms; i++) {
        __delay_ms(1);
    }
}

// Helper functions
uint16_t read_u16_pgm(const uint8_t *ptr, uint8_t idx) {
    return ptr[idx] | (ptr[idx + 1] << 8);
}

uint8_t read_u8_pgm(const uint8_t *ptr, uint8_t idx) {
    return ptr[idx];
}













