/**
 * Enhanced ATmega328P LED Pattern Player - Upload Bridge Template
 * 
 * Advanced pattern player with brightness curves, speed control, and interpolation
 * Generated by Upload Bridge - github.com/yourname/upload-bridge
 */

#include <avr/io.h>
#include <avr/interrupt.h>
#include <avr/pgmspace.h>
#include <util/delay.h>
#include <math.h>
#include "pattern_data.h"

// WS2812 timing constants (for 16MHz clock)
#define T1H  900    // 0.9us
#define T1L  350    // 0.35us
#define T0H  350    // 0.35us  
#define T0L  900    // 0.9us
#define RES  50000  // 50us reset

// Advanced brightness control
#define BRIGHTNESS_CURVE_LINEAR 0
#define BRIGHTNESS_CURVE_GAMMA_CORRECTED 1
#define BRIGHTNESS_CURVE_LOGARITHMIC 2
#define BRIGHTNESS_CURVE_EXPONENTIAL 3
#define BRIGHTNESS_CURVE_S_CURVE 4

// Speed control
#define SPEED_CURVE_LINEAR 0
#define SPEED_CURVE_EASE_IN_QUAD 1
#define SPEED_CURVE_EASE_OUT_QUAD 2
#define SPEED_CURVE_EASE_IN_OUT_QUAD 3

// Default settings (overridden by pattern_data.h)
#ifndef DATA_PIN
#define DATA_PIN 2
#endif

#ifndef LED_COUNT
#define LED_COUNT 76
#endif

#define MAX_LEDS 100  // Optimized for ATmega328P memory (32KB flash, 2KB RAM, max 100 LEDs)

// LED buffer in RAM
uint8_t led_buffer[MAX_LEDS * 3];

// Global settings
float global_brightness = 1.0;
float red_brightness = 1.0;
float green_brightness = 1.0;
float blue_brightness = 1.0;
bool per_channel_brightness = false;
uint8_t brightness_curve = BRIGHTNESS_CURVE_GAMMA_CORRECTED;

// Function prototypes
void ws2812_init(uint8_t pin);
void ws2812_send_byte(uint8_t byte);
void ws2812_send(uint8_t *data, uint16_t len);
uint16_t read_u16_pgm(const uint8_t *ptr, uint16_t idx);
uint8_t read_u8_pgm(const uint8_t *ptr, uint16_t idx);
float apply_brightness_curve(float value, uint8_t curve_type);
void apply_brightness_to_pixel(uint8_t *r, uint8_t *g, uint8_t *b, float brightness);

int main(void) {
    // Initialize WS2812 pin as output
    if (DATA_PIN < 8) {
        DDRD |= (1 << DATA_PIN);
    } else {
        DDRB |= (1 << (DATA_PIN - 8));
    }
    
    // Load advanced settings from pattern metadata
    global_brightness = BRIGHTNESS / 255.0;
    red_brightness = red_brightness / 255.0;
    green_brightness = green_brightness / 255.0;
    blue_brightness = blue_brightness / 255.0;
    per_channel_brightness = per_channel_brightness;
    brightness_curve = brightness_curve;
    
    // Main loop
    while (1) {
        // Read pattern header
        const uint8_t *p = pattern_data;
        uint16_t idx = 0;
        
        uint16_t num_leds = read_u16_pgm(p, idx);
        idx += 2;
        
        uint16_t num_frames = read_u16_pgm(p, idx);
        idx += 2;
        
        // Play all frames
        for (uint16_t frame = 0; frame < num_frames; frame++) {
            // Read frame delay
            uint16_t delay_ms = read_u16_pgm(p, idx);
            idx += 2;
            
            // Read RGB data for all LEDs
            for (uint16_t led = 0; led < num_leds; led++) {
                uint8_t r = read_u8_pgm(p, idx++);
                uint8_t g = read_u8_pgm(p, idx++);
                uint8_t b = read_u8_pgm(p, idx++);
                
                // Apply advanced brightness
                apply_brightness_to_pixel(&r, &g, &b, global_brightness);
                
                // Store in buffer
                led_buffer[led * 3] = r;
                led_buffer[led * 3 + 1] = g;
                led_buffer[led * 3 + 2] = b;
            }
            
            // Send to LEDs
            ws2812_send(led_buffer, num_leds * 3);
            
            // Delay
            for (uint16_t i = 0; i < delay_ms; i++) {
                _delay_ms(1);
            }
        }
    }
}

float apply_brightness_curve(float value, uint8_t curve_type) {
    if (value < 0.0) value = 0.0;
    if (value > 1.0) value = 1.0;
    
    switch (curve_type) {
        case BRIGHTNESS_CURVE_LINEAR:
            return value;
            
        case BRIGHTNESS_CURVE_GAMMA_CORRECTED:
            // Approximate gamma correction using lookup table
            return value * value; // Simplified gamma 2.0
            
        case BRIGHTNESS_CURVE_LOGARITHMIC:
            if (value == 0.0) return 0.0;
            return log(1.0 + value * 9.0) / log(10.0);
            
        case BRIGHTNESS_CURVE_EXPONENTIAL:
            return value * value;
            
        case BRIGHTNESS_CURVE_S_CURVE:
            return 3.0 * value * value - 2.0 * value * value * value;
            
        default:
            return value;
    }
}

void apply_brightness_to_pixel(uint8_t *r, uint8_t *g, uint8_t *b, float brightness) {
    if (per_channel_brightness) {
        // Per-channel brightness control
        *r = (uint8_t)(*r * brightness * red_brightness);
        *g = (uint8_t)(*g * brightness * green_brightness);
        *b = (uint8_t)(*b * brightness * blue_brightness);
    } else {
        // Apply brightness curve
        float curved_brightness = apply_brightness_curve(brightness, brightness_curve);
        
        *r = (uint8_t)(*r * curved_brightness);
        *g = (uint8_t)(*g * curved_brightness);
        *b = (uint8_t)(*b * curved_brightness);
    }
}

// WS2812 bit-banging functions (unchanged)
void ws2812_init(uint8_t pin) {
    if (pin < 8) {
        DDRD |= (1 << pin);
    } else {
        DDRB |= (1 << (pin - 8));
    }
}

void ws2812_send_byte(uint8_t byte) {
    for (uint8_t i = 0; i < 8; i++) {
        if (byte & 0x80) {
            // Send 1
            if (DATA_PIN < 8) {
                PORTD |= (1 << DATA_PIN);
                _delay_us(T1H);
                PORTD &= ~(1 << DATA_PIN);
                _delay_us(T1L);
            } else {
                PORTB |= (1 << (DATA_PIN - 8));
                _delay_us(T1H);
                PORTB &= ~(1 << (DATA_PIN - 8));
                _delay_us(T1L);
            }
        } else {
            // Send 0
            if (DATA_PIN < 8) {
                PORTD |= (1 << DATA_PIN);
                _delay_us(T0H);
                PORTD &= ~(1 << DATA_PIN);
                _delay_us(T0L);
            } else {
                PORTB |= (1 << (DATA_PIN - 8));
                _delay_us(T0H);
                PORTB &= ~(1 << (DATA_PIN - 8));
                _delay_us(T0L);
            }
        }
        byte <<= 1;
    }
}

void ws2812_send(uint8_t *data, uint16_t len) {
    for (uint16_t i = 0; i < len; i++) {
        ws2812_send_byte(data[i]);
    }
    _delay_us(RES);
}

// Helper functions
uint16_t read_u16_pgm(const uint8_t *ptr, uint16_t idx) {
    uint8_t b0 = pgm_read_byte(ptr + idx);
    uint8_t b1 = pgm_read_byte(ptr + idx + 1);
    return (uint16_t)(b0 | (b1 << 8));
}

uint8_t read_u8_pgm(const uint8_t *ptr, uint16_t idx) {
    return pgm_read_byte(ptr + idx);
}
