/**
 * ATmega328P LED Pattern Player - Upload Bridge Template
 * 
 * Plays LED animation patterns stored in PROGMEM to WS2812 LEDs
 * Generated by Upload Bridge
 */

#include <avr/io.h>
#include <avr/interrupt.h>
#include <avr/pgmspace.h>
#include <util/delay.h>
#include "pattern_data.h"

// WS2812 timing constants (for 16MHz clock)
#define T1H  900    // 0.9us
#define T1L  350    // 0.35us
#define T0H  350    // 0.35us  
#define T0L  900    // 0.9us
#define RES  50000  // 50us reset

// Default settings (overridden by pattern_data.h)
#ifndef DATA_PIN
#define DATA_PIN 2
#endif

#ifndef LED_COUNT
#define LED_COUNT 76
#endif

#define MAX_LEDS 100  // Optimized for ATmega328P memory (32KB flash, 2KB RAM, max 100 LEDs)

// LED buffer in RAM
uint8_t led_buffer[MAX_LEDS * 3];

// Function prototypes
void ws2812_init(uint8_t pin);
void ws2812_send_byte(uint8_t byte);
void ws2812_send(uint8_t *data, uint16_t len);
uint16_t read_u16_pgm(const uint8_t *ptr, uint16_t idx);
uint8_t read_u8_pgm(const uint8_t *ptr, uint16_t idx);

int main(void) {
    // Initialize WS2812 pin as output
    if (DATA_PIN < 8) {
        DDRD |= (1 << DATA_PIN);
    } else {
        DDRB |= (1 << (DATA_PIN - 8));
    }
    
    // Read pattern header
    uint16_t num_leds = read_u16_pgm(pattern_data, 0);
    uint16_t num_frames = read_u16_pgm(pattern_data, 2);
    
    // Clamp to maximum
    if (num_leds > MAX_LEDS) {
        num_leds = MAX_LEDS;
    }
    
    // Main loop
    while (1) {
        uint16_t idx = 4;  // Start after header
        
        // Play all frames
        for (uint16_t frame = 0; frame < num_frames; frame++) {
            // Read frame delay
            uint16_t delay_ms = read_u16_pgm(pattern_data, idx);
            idx += 2;
            
            // Read RGB data into buffer
            for (uint16_t led = 0; led < num_leds; led++) {
                led_buffer[led * 3 + 0] = read_u8_pgm(pattern_data, idx++);  // R
                led_buffer[led * 3 + 1] = read_u8_pgm(pattern_data, idx++);  // G
                led_buffer[led * 3 + 2] = read_u8_pgm(pattern_data, idx++);  // B
            }
            
            // Send to LEDs
            ws2812_send(led_buffer, num_leds * 3);
            
            // Delay
            for (uint16_t i = 0; i < delay_ms; i++) {
                _delay_ms(1);
            }
        }
    }
    
    return 0;
}

// Initialize WS2812 output pin
void ws2812_init(uint8_t pin) {
    if (pin < 8) {
        DDRD |= (1 << pin);
        PORTD &= ~(1 << pin);
    } else {
        DDRB |= (1 << (pin - 8));
        PORTB &= ~(1 << (pin - 8));
    }
}

// Send one byte to WS2812 (bit-banging)
void ws2812_send_byte(uint8_t byte) {
    for (uint8_t bit = 0; bit < 8; bit++) {
        if (byte & 0x80) {
            // Send '1' bit
            if (DATA_PIN < 8) {
                PORTD |= (1 << DATA_PIN);
                __asm__ __volatile__ ("nop\n\t nop\n\t nop\n\t");
                PORTD &= ~(1 << DATA_PIN);
            } else {
                PORTB |= (1 << (DATA_PIN - 8));
                __asm__ __volatile__ ("nop\n\t nop\n\t nop\n\t");
                PORTB &= ~(1 << (DATA_PIN - 8));
            }
        } else {
            // Send '0' bit
            if (DATA_PIN < 8) {
                PORTD |= (1 << DATA_PIN);
                __asm__ __volatile__ ("nop\n\t");
                PORTD &= ~(1 << DATA_PIN);
                __asm__ __volatile__ ("nop\n\t nop\n\t");
            } else {
                PORTB |= (1 << (DATA_PIN - 8));
                __asm__ __volatile__ ("nop\n\t");
                PORTB &= ~(1 << (DATA_PIN - 8));
                __asm__ __volatile__ ("nop\n\t nop\n\t");
            }
        }
        byte <<= 1;
    }
}

// Send buffer to WS2812 LEDs
void ws2812_send(uint8_t *data, uint16_t len) {
    cli();  // Disable interrupts for timing-critical section
    
    for (uint16_t i = 0; i < len; i++) {
        ws2812_send_byte(data[i]);
    }
    
    sei();  // Re-enable interrupts
    
    // Reset pulse
    _delay_us(50);
}

// Read 16-bit value from PROGMEM (little-endian)
uint16_t read_u16_pgm(const uint8_t *ptr, uint16_t idx) {
    uint8_t b0 = pgm_read_byte(ptr + idx);
    uint8_t b1 = pgm_read_byte(ptr + idx + 1);
    return (uint16_t)(b0 | (b1 << 8));
}

// Read 8-bit value from PROGMEM
uint8_t read_u8_pgm(const uint8_t *ptr, uint16_t idx) {
    return pgm_read_byte(ptr + idx);
}

