/**
 * Professional STM32F103 LED Pattern Player - Upload Bridge Template
 * 
 * Full professional-grade pattern player with all advanced features
 * Optimized for STM32F103C8 with 64KB flash and 20KB RAM
 * Generated by Upload Bridge - Professional Edition
 */

#include "stm32f1xx.h"
#include <math.h>
#include <string.h>
#include "pattern_data.h"

// Advanced brightness control
#define BRIGHTNESS_CURVE_LINEAR 0
#define BRIGHTNESS_CURVE_GAMMA_CORRECTED 1
#define BRIGHTNESS_CURVE_LOGARITHMIC 2
#define BRIGHTNESS_CURVE_EXPONENTIAL 3
#define BRIGHTNESS_CURVE_S_CURVE 4

// Speed control
#define SPEED_CURVE_LINEAR 0
#define SPEED_CURVE_EASE_IN_QUAD 1
#define SPEED_CURVE_EASE_OUT_QUAD 2
#define SPEED_CURVE_EASE_IN_OUT_QUAD 3
#define SPEED_CURVE_EASE_IN_CUBIC 4
#define SPEED_CURVE_EASE_OUT_CUBIC 5
#define SPEED_CURVE_EASE_IN_OUT_CUBIC 6

// Default settings (overridden by pattern_data.h)
#ifndef DATA_PIN
#define DATA_PIN 2
#endif

#ifndef LED_COUNT
#define LED_COUNT 76
#endif

#define MAX_LEDS 300  // Optimized for STM32F103C8 memory

// LED buffer in RAM
uint8_t led_buffer[MAX_LEDS * 3];

// Global settings
float global_brightness = 1.0;
float red_brightness = 1.0;
float green_brightness = 1.0;
float blue_brightness = 1.0;
bool per_channel_brightness = false;
uint8_t brightness_curve = BRIGHTNESS_CURVE_GAMMA_CORRECTED;
uint8_t speed_curve = SPEED_CURVE_LINEAR;
bool variable_speed = false;
bool interpolation_enabled = false;
float interpolation_factor = 1.0;

// Speed keyframes (max 16 keyframes for STM32)
struct SpeedKeyframe {
    uint16_t frame;
    float multiplier;
};
SpeedKeyframe speed_keyframes[16];
uint8_t num_keyframes = 0;

// Interpolation buffer for smooth transitions
uint8_t interpolation_buffer[MAX_LEDS * 3];

// Function prototypes
void ws2812_init(uint8_t pin);
void ws2812_send_byte(uint8_t byte);
void ws2812_send(uint8_t *data, uint16_t len);
uint16_t read_u16_pgm(const uint8_t *ptr, uint16_t idx);
uint8_t read_u8_pgm(const uint8_t *ptr, uint16_t idx);
float apply_brightness_curve(float value, uint8_t curve_type);
float apply_speed_curve(float t, uint8_t curve_type);
uint16_t get_frame_delay(uint16_t base_delay, uint32_t frame, uint32_t total_frames);
void apply_brightness_to_pixel(uint8_t *r, uint8_t *g, uint8_t *b, float brightness);
void interpolate_frames(uint8_t *frame1, uint8_t *frame2, uint8_t *output, float t, uint16_t led_count);
void process_frame_with_interpolation(const uint8_t *pattern_data, uint16_t frame_idx, uint16_t total_frames, uint16_t led_count);
void delay_ms(uint32_t ms);
void system_clock_config(void);

int main(void) {
    // Initialize system clock
    system_clock_config();
    
    // Initialize WS2812 pin
    ws2812_init(DATA_PIN);
    
    // Load advanced settings from pattern metadata
    global_brightness = BRIGHTNESS / 255.0;
    red_brightness = red_brightness / 255.0;
    green_brightness = green_brightness / 255.0;
    blue_brightness = blue_brightness / 255.0;
    per_channel_brightness = per_channel_brightness;
    brightness_curve = brightness_curve;
    speed_curve = speed_curve;
    variable_speed = variable_speed;
    interpolation_enabled = interpolation_enabled;
    interpolation_factor = interpolation_factor / 10.0;
    
    // Load speed keyframes
    num_keyframes = num_keyframes;
    for (uint8_t i = 0; i < num_keyframes && i < 16; i++) {
        speed_keyframes[i].frame = speed_keyframes[i].frame;
        speed_keyframes[i].multiplier = speed_keyframes[i].multiplier;
    }
    
    // Main loop
    while (1) {
        // Read pattern header
        const uint8_t *p = pattern_data;
        uint32_t idx = 0;
        
        uint16_t num_leds = read_u16_pgm(p, idx);
        idx += 2;
        
        uint16_t num_frames = read_u16_pgm(p, idx);
        idx += 2;
        
        // Limit LED count to available memory
        if (num_leds > MAX_LEDS) {
            num_leds = MAX_LEDS;
        }
        
        // Play all frames with advanced features
        for (uint32_t frame = 0; frame < num_frames; frame++) {
            process_frame_with_interpolation(p, frame, num_frames, num_leds);
        }
    }
}

void process_frame_with_interpolation(const uint8_t *pattern_data, uint16_t frame_idx, uint16_t total_frames, uint16_t led_count) {
    // Read frame delay
    uint16_t base_delay = read_u16_pgm(pattern_data, 4 + frame_idx * (led_count * 3 + 2));
    
    // Apply speed curve if enabled
    uint16_t delay_ms = get_frame_delay(base_delay, frame_idx, total_frames);
    
    // Read current frame
    uint32_t frame_offset = 4 + frame_idx * (led_count * 3 + 2) + 2;
    for (uint16_t led = 0; led < led_count; led++) {
        uint8_t r = read_u8_pgm(pattern_data, frame_offset + led * 3);
        uint8_t g = read_u8_pgm(pattern_data, frame_offset + led * 3 + 1);
        uint8_t b = read_u8_pgm(pattern_data, frame_offset + led * 3 + 2);
        
        // Apply advanced brightness
        apply_brightness_to_pixel(&r, &g, &b, global_brightness);
        
        // Store in buffer
        led_buffer[led * 3] = r;
        led_buffer[led * 3 + 1] = g;
        led_buffer[led * 3 + 2] = b;
    }
    
    // Apply interpolation if enabled
    if (interpolation_enabled && frame_idx < total_frames - 1) {
        // Read next frame for interpolation
        uint32_t next_frame_offset = 4 + (frame_idx + 1) * (led_count * 3 + 2) + 2;
        for (uint16_t led = 0; led < led_count; led++) {
            uint8_t r = read_u8_pgm(pattern_data, next_frame_offset + led * 3);
            uint8_t g = read_u8_pgm(pattern_data, next_frame_offset + led * 3 + 1);
            uint8_t b = read_u8_pgm(pattern_data, next_frame_offset + led * 3 + 2);
            
            // Apply brightness to next frame
            apply_brightness_to_pixel(&r, &g, &b, global_brightness);
            
            // Store in interpolation buffer
            interpolation_buffer[led * 3] = r;
            interpolation_buffer[led * 3 + 1] = g;
            interpolation_buffer[led * 3 + 2] = b;
        }
        
        // Interpolate between frames
        float t = 1.0 / interpolation_factor;
        interpolate_frames(led_buffer, interpolation_buffer, led_buffer, t, led_count);
    }
    
    // Send to LEDs
    ws2812_send(led_buffer, led_count * 3);
    
    // Delay
    delay_ms(delay_ms);
}

float apply_brightness_curve(float value, uint8_t curve_type) {
    if (value < 0.0) value = 0.0;
    if (value > 1.0) value = 1.0;
    
    switch (curve_type) {
        case BRIGHTNESS_CURVE_LINEAR:
            return value;
            
        case BRIGHTNESS_CURVE_GAMMA_CORRECTED:
            // Full gamma correction for STM32
            return pow(value, 1.0 / 2.2);
            
        case BRIGHTNESS_CURVE_LOGARITHMIC:
            if (value == 0.0) return 0.0;
            return log(1.0 + value * 9.0) / log(10.0);
            
        case BRIGHTNESS_CURVE_EXPONENTIAL:
            return value * value;
            
        case BRIGHTNESS_CURVE_S_CURVE:
            return 3.0 * value * value - 2.0 * value * value * value;
            
        default:
            return value;
    }
}

float apply_speed_curve(float t, uint8_t curve_type) {
    if (t < 0.0) t = 0.0;
    if (t > 1.0) t = 1.0;
    
    switch (curve_type) {
        case SPEED_CURVE_LINEAR:
            return t;
            
        case SPEED_CURVE_EASE_IN_QUAD:
            return t * t;
            
        case SPEED_CURVE_EASE_OUT_QUAD:
            return 1 - (1 - t) * (1 - t);
            
        case SPEED_CURVE_EASE_IN_OUT_QUAD:
            if (t < 0.5) return 2 * t * t;
            return 1 - 2 * (1 - t) * (1 - t);
            
        case SPEED_CURVE_EASE_IN_CUBIC:
            return t * t * t;
            
        case SPEED_CURVE_EASE_OUT_CUBIC:
            return 1 - pow(1 - t, 3);
            
        case SPEED_CURVE_EASE_IN_OUT_CUBIC:
            if (t < 0.5) return 4 * t * t * t;
            return 1 - 4 * pow(1 - t, 3);
            
        default:
            return t;
    }
}

uint16_t get_frame_delay(uint16_t base_delay, uint32_t frame, uint32_t total_frames) {
    if (!variable_speed) {
        return base_delay;
    }
    
    // Apply speed curve
    float t = (float)frame / (total_frames - 1);
    float curve_factor = apply_speed_curve(t, speed_curve);
    
    // Apply keyframes if available
    float keyframe_factor = 1.0;
    for (uint8_t i = 0; i < num_keyframes; i++) {
        if (frame >= speed_keyframes[i].frame) {
            keyframe_factor = speed_keyframes[i].multiplier;
        }
    }
    
    return (uint16_t)(base_delay / (curve_factor * keyframe_factor));
}

void apply_brightness_to_pixel(uint8_t *r, uint8_t *g, uint8_t *b, float brightness) {
    if (per_channel_brightness) {
        // Per-channel brightness control
        *r = (uint8_t)(*r * brightness * red_brightness);
        *g = (uint8_t)(*g * brightness * green_brightness);
        *b = (uint8_t)(*b * brightness * blue_brightness);
    } else {
        // Apply brightness curve
        float curved_brightness = apply_brightness_curve(brightness, brightness_curve);
        
        *r = (uint8_t)(*r * curved_brightness);
        *g = (uint8_t)(*g * curved_brightness);
        *b = (uint8_t)(*b * curved_brightness);
    }
}

void interpolate_frames(uint8_t *frame1, uint8_t *frame2, uint8_t *output, float t, uint16_t led_count) {
    for (uint16_t led = 0; led < led_count; led++) {
        uint8_t r1 = frame1[led * 3];
        uint8_t g1 = frame1[led * 3 + 1];
        uint8_t b1 = frame1[led * 3 + 2];
        
        uint8_t r2 = frame2[led * 3];
        uint8_t g2 = frame2[led * 3 + 1];
        uint8_t b2 = frame2[led * 3 + 2];
        
        // Linear interpolation
        output[led * 3] = (uint8_t)(r1 + (r2 - r1) * t);
        output[led * 3 + 1] = (uint8_t)(g1 + (g2 - g1) * t);
        output[led * 3 + 2] = (uint8_t)(b1 + (b2 - b1) * t);
    }
}

void system_clock_config(void) {
    // Enable HSE and wait for it to be ready
    RCC->CR |= RCC_CR_HSEON;
    while (!(RCC->CR & RCC_CR_HSERDY));
    
    // Configure PLL for 72MHz
    RCC->CFGR |= RCC_CFGR_PLLSRC;  // HSE as PLL source
    RCC->CFGR |= RCC_CFGR_PLLMUL_7; // PLL x9 (8MHz * 9 = 72MHz)
    
    // Enable PLL and wait for it to be ready
    RCC->CR |= RCC_CR_PLLON;
    while (!(RCC->CR & RCC_CR_PLLRDY));
    
    // Configure flash latency
    FLASH->ACR |= FLASH_ACR_LATENCY_2; // 2 wait states for 72MHz
    
    // Switch to PLL
    RCC->CFGR |= RCC_CFGR_SW_PLL;
    while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_PLL);
}

void ws2812_init(uint8_t pin) {
    // Enable GPIOA clock
    RCC->APB2ENR |= RCC_APB2ENR_IOPAEN;
    
    // Configure pin as output, 50MHz
    if (pin < 8) {
        GPIOA->CRL &= ~(0xF << (pin * 4));
        GPIOA->CRL |= (0x3 << (pin * 4));
    } else {
        GPIOA->CRH &= ~(0xF << ((pin - 8) * 4));
        GPIOA->CRH |= (0x3 << ((pin - 8) * 4));
    }
}

void ws2812_send_byte(uint8_t byte) {
    // STM32 WS2812 bit-banging implementation (optimized for 72MHz)
    for (uint8_t i = 0; i < 8; i++) {
        if (byte & 0x80) {
            // Send 1 (0.9us high, 0.35us low)
            GPIOA->BSRR = (1 << DATA_PIN);
            for (volatile int j = 0; j < 12; j++); // ~0.9us at 72MHz
            GPIOA->BRR = (1 << DATA_PIN);
            for (volatile int j = 0; j < 4; j++);  // ~0.35us at 72MHz
        } else {
            // Send 0 (0.35us high, 0.9us low)
            GPIOA->BSRR = (1 << DATA_PIN);
            for (volatile int j = 0; j < 4; j++);  // ~0.35us at 72MHz
            GPIOA->BRR = (1 << DATA_PIN);
            for (volatile int j = 0; j < 12; j++); // ~0.9us at 72MHz
        }
        byte <<= 1;
    }
}

void ws2812_send(uint8_t *data, uint16_t len) {
    for (uint16_t i = 0; i < len; i++) {
        ws2812_send_byte(data[i]);
    }
    // Reset pulse
    GPIOA->BRR = (1 << DATA_PIN);
    for (volatile int i = 0; i < 500; i++); // ~50us at 72MHz
}

void delay_ms(uint32_t ms) {
    // Simple delay loop for STM32F103 at 72MHz
    for (uint32_t i = 0; i < ms; i++) {
        for (volatile int j = 0; j < 8000; j++); // ~1ms at 72MHz
    }
}

// Helper functions
uint16_t read_u16_pgm(const uint8_t *ptr, uint16_t idx) {
    return ptr[idx] | (ptr[idx + 1] << 8);
}

uint8_t read_u8_pgm(const uint8_t *ptr, uint16_t idx) {
    return ptr[idx];
}













